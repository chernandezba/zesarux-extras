*                   JS - DISASSEMBLY
*
* ---------------------------------------------------------------
* THIS VERSION CONTAINS IN BASIC3_ASM CORRECTIONS THAT HAVE BEEN
* NECESSARY - SORRY I SELDOM USE BASIC, THAT'S WHY I DID NOT NOTICE
* THE BUGS - LOCATION: L08B2A  L0932E  L08DAA
* ALL CORRECTIONS ARE MARKED WITH !!! CORRECTED
*
* SOME ADDITIONAL COMMENTS HAVE BEEN MADE - YET THERE'S FEW
* OF THEM!!
* I hope that this disassembly is correct - if you find any faults:
* Drop me a line. 
* BY INTENSIVE TESTING OF OWN CODE I COULD FIND NO BUG -
* BUT OF COURSE IT'S IMPOSSIBLE TO TEST ANY CONFIGURATION
* THOUGH THERE MIGHT BE SOMEWHERE A WRONG DEFINITION THAT WILL
* BE NOTICED ONLY, IF YOU HAPPEN TO INSERT JUST THERE SOME CODE.
* IN FACT, I'M QUITE SURE THAT NOW EVERYTHING IS WORKING IN ANY 
* CONIGURATION IF YOU KEEP IN MIND THAT SOME CODE RETURNS WITH
* MANIPLUATED STACK - SEE ADDER ON MDV-VECTORS: THERE ARE THREE
* POSSIBLE REUTRNS SOMETIMES.
* Don't write to me with 'just one question' on details.
* I think the disassembly is enough work.
*
* The disassembly is poorly commented - but those who will be
* working with it, know what they are doing anyhow!
*
*                   IMPORTANT
*
* The disassembly is for private use only.
* Any commercial usage is  N O T  allowed.
* QDOS is copyright by SINCLAIR / ARMSTRAD!!!!
*
* Even TONY TEBBY was not allowed to use his QDOS on his
* FUTURA project. He had to rewrite QDOS!
*
* It is evident, that nobody else may use QDOS commercial when even
* he was not entitled to use it.
*
* I was offered to use this disassembly comercial. 
*                I refused to do so.
* 
* Only fools (!!) will try to market any part of this disassembly.
*
* ---------------------------------------------------------------------
* ---------------------------------------------------------------------
*            How to use this disassembly
*
* LOOK and learn from it - you own programming technique might profit.
*
* Don't write progs that access direct the ROM.
*
* Use the defined TRAPS and VECTORS.
*
* If you want to change things ½ hope that you know what you are doing
* 
* REASSEMBLY ONLY WITH GST MACRO ASSEMBLER POSSIBLE
* Minimum configuration: 256 K memory expansion + diskdrive
*
* USE OPTION -NOLIST OR YOU WILL RUN OUT OF DISKSPACE
* 
* ESSENTIAL FOR UNDERSTANDING: ADDER "QL ADVANCED USER GUIDE"
* REFFERENCES TO THIS BOOK IN MY COMMENTS AS ½Adder 
* ---------------------------------------------------------------
* 
* Please note: all values that I've been redifinig for use as Labels
* have significant names: XL-labels are labels that are defined by
* using an EQU somewhere in the Prog.
* Tr -labels are labels for TRAPS e.g. 
* Tr1d03 is label of Trap 1 with d0=3
* Tr3d12 is label of Trap 3 with d0=$12
* labels that start with 'o' have been installed for 
* my own use during the disassembly-work
* any critical comments are marked with '!!'
* any doubts - yes there are some - are marked with '?'
*
* SOME comments might be silly - but have been of any value for
* me when I did the disassembly. I don't want to put them out
* you can enjoy them or erase them as you like.
*
* FOR TESTING PURPOSES I'VE ADDED SOME 'NOP' TO PREVENT THAT
* THE GST-MACRO ASSEMBLER PRODUCES SHORTER CODE - MOST NOP's MIGHT
* BE OMITTED - DO IT YOURSELF - But: Control it thoroughfully:
* Especially in BASIC and MDV-routines returns form subroutines
* manipulate the Stack(a7). Changing code could mean that
* the adress for Return was wrong.
* 
* YOU WILL FIND INCLUDED EVEN KEYBOARD_ASM FOR MGG VERSION
* THE JM_MDV_ROUTINES MIGHT NEED SOME MODIFICATIONS
* IT'S JUST AN ATTEMPT TO REPLACE THE UNNECESSARY LONG JS-
* ROUTINES.
* BUT: THE JM-ROUTINES MIGHT HAVE A BUG. SO TRY IT WITH
* CAUTION. 
* ON TRA_TAB: SINCE I WORK ON MY QL WITH EPROMS AND LOST MY ORIGINAL
* JS-FILE IT MIGHT BE WORTH, ADAPTING THAT PIECE OF BYTES EXACTLS
* TO YOUR PRINTER. AS IT IS, IT WORKS PERFECTLY WELL WITH THE 
* BROTHER EP 44 PRINTER IN T/W MODE - AT LEAST WITH THE VERSION THAT
* HAS BEEN DELIVERED IN SWITZERLAND.
* 
* 
* MY ADRESS:
*             WOLFGANG GOELLER
*             ROSENSTR. 21
*             CH 8105 REGENSDORF
*             SWITZERLAND
*

       org     $00
       NOLIST
       DC.L    $00030000  * RESET supervisor-stack
       DC.W    $0000
       dc.W    XL0016A    * RESET prog - start
       DC.W    $0000
       DC.W    XL0005C    * bus error
       DC.L    $00000028  * adress - error
       DC.L    $0000002A  * ilegal instruction
       DC.L    $0000002C  * divison by zero
       DC.L    $0000002E  * CHK-instruction
       DC.L    $00000030  * TRAPV
       DC.L    $00000032  * privilege violation
       DC.L    $00000034  * trace
o028   BSR.S   L00050     * 1010-  trap * dc.l $61266124
o02a   BSR.S   L00050
o02c   BSR.S   L00050     * 1111-  trap * dc.l $61226120
o02e   BSR.S   L00050
o030   BSR.S   L00050
o032   BSR.S   L00050
o034   BSR.S   L00050
o036   BSR.S   L00050
0o38   BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       BSR.S   L00050
       DC.W    $0000
L00050 BRA     L0013C           * Test Interrupt
L00054 SUBI.L  #$0000002A,(A7)+ * suppress Backaddr
       BNE.S   L0005E           * erroradress 
L0005C ADDQ.W  #8,A7            * yes: restore backaddr. 

XL0005C EQU L0005C

L0005E RTE
oo60    DC.L    L0005E          * 
oo64    DC.L    L0005E          *  interrupt L1
oo68    DC.L    XL00352         *            L2
oo6C    DC.L    L0005E
oo70    DC.L    L0005E
oo74    DC.L    L0005E
oo78    DC.L    L0005E
oo7c    DC.L    $00000036       *  ...       L7
oo80    DC.L    XLTRAP0
oo84    DC.L    XLTRAP1
oo88    DC.L    XLTRAP2
oo8C    DC.L    XLTRAP3
oo90    DC.L    XLTRAP4
        DC.L    $00000038  * vectors for Trap 5 - 15
oo98    DC.L    $0000003A
oo9C    DC.L    $0000003C
ooA0    DC.L    $0000003E
ooA4    DC.L    $00000040
ooA8    DC.L    $00000042
ooAC    DC.L    $00000044
ooB0    DC.L    $00000046
ooB4    DC.L    $00000048
L000B8 DC.L    $0000004A
       DC.L    $0000004C
ooC0   DC.W    L02FAE   * MM.ALCHP
       DC.W    L0305E   * MM.RECHP
ooC4   DC.W    L039F2   * UT.WINDW
       DC.W    L039F6   * UT.CON
ooC8   DC.W    L039FC   * UT.SCR
       DC.W    L0395E   * UT.ERR0
ooCC   DC.W    L03968   * UT.ERR
       DC.W    L03990   * UT.MINT
ooD0   DC.W    L039B2   * UT.MTEXT
       DC.W    L039DC   * UT.LINK
ooD4   DC.W    L039E2   * UT.UNLNK
       DC.W    $0000
oD8    DC.W    L03104   * MM.ALLOC
       DC.W    L03162   * MM.LINKFR
oDC    DC.W    L037F4   * IO.QSET
       DC.W    L0380A   * IO.QTEST
oE0    DC.W    L03838   * IO.QIN
       DC.W    L0385E   * IO.QOUT
oE4    DC.W    L03888   * IO.QEOF
       DC.W    L03A9C   * UT.CSTR
oE8    DC.W    L037CC   * IO.SERQ
       DC.W    L0388C   * IO.SERIO
oEC    DC.W    L0405E   * CN.DATE
       DC.W    L040BE   * CN.DAY
oF0    DC.W    L03EF6   * CN.FTOD
       DC.W    L03E54   * CN.ITOD
L000F4 DC.W    L03EDC   * CN.ITOBB
       DC.W    L03ED8   * CN.ITOBW
       DC.W    L03ED4   * CN.ITOBL
       DC.W    L03EB0   * CN.ITOHB
L000FC DC.W    L03EAC   * CN.ITOHW
       DC.W    L03EA8   * CN.ITOHL
o00100 DC.W    L03D16   * CN.DTOF
       DC.W    L03DC2   * CN.DTOI
o104   DC.W    L03E34   * CN.BTOIB
       DC.W    L03E38   * CN.BTOIW
o108   DC.W    L03E3C   * CN.BTOIL
       DC.W    L03DD4   * CN.HTOIB
o10c   DC.W    L03DD8   * CN.HTOIW
       DC.W    L03DDC   * CN.HTOIL
o110   DC.W    L06DA6   * BP.INIT
       DC.W    L061DA   * CA.GTINT
       DC.W    L061DE   * CA.GTFP
       DC.W    L061D6   * CA.GTSTR
       DC.W    L061E2   * CA.GTLIN
       DC.W    L04E4E   * BV.CHRIX
       DC.W    L041AC   * RI.EXEC
       DC.W    L041B4   * RI.EXECB
       DC.W    L072C2   * BP.LET
o00122 DC.W    L0372C   * IO.DECODE
* from now on: add $4000 to get the correct adress 
* refer to Adder ½ vectors 124 ff

o00124 DC.W    XL0125C   * MD.READ  - 525C
       DC.W    XL011B0   * MD.WRITE - 51B0
       DC.W    XL01262   * MD.VERIN - 5262
       DC.W    XL0123A   * MD.SECTR - 523A
       DC.W    XL047D4   * BASIC SYNTAX ANALYSER               - 87D4
       DC.W    XL04B5A   * FIRST SYNTAX TABLE - COMMANDS       - 8B5A
* next adress is odd!! don't mistrust - it is really odd !!!
       DC.W    XL04CE7   * SECOND SYNTAX TABLE - EXPRESSIONS   - 8CE7
       DC.W    XL04AB4   * FORMAT PRECOMPILED BASIC LINE       - 8AB4
       DC.W    XL04A4E   * ERROR WHEN COMPILING                - 8A4E
       DC.W    XL04E88   * STORE PRECOMPILE LINE               - 8E88
       DC.W    XL03518   * CONVERT PRECOMPILED BASIC TO ASCII  - 7518
       DC.W    XL0490C   * INITIALISE BASIC STACKS             - 890C
       
L0013C TST.L   $00028050   * Test for redirection
       BEQ     L00054      * no
       MOVE.L  A6,-(A7)    * a6 on stack
       MOVEA.W $0006(A7),A6  *  
       ADDA.W  A6,A6
       ADDA.L  $00028050,A6  * a6 pointer to redirect-routine
       MOVE.L  (A6),$0004(A7) 
       MOVEA.L (A7)+,A6      * restore a6
       RTS

Ramerror 
L0015C MOVEA.L A3,A5        * endless loop
L0015E MOVE.W  D7,(A5)+
       CMPA.L  #$00028000,A5
       BNE.S   L0015E
       BRA.S   L0015C

* start QL init/reset
L0016A MOVEA.L #$00040000,A1     * Ramtest
XL0016A EQU L0016A
       MOVEA.L A1,A4
L00172 MOVE.L  A4,(A4)
       CMPA.L  (A4),A4
       BNE.S   L00184            * till A1 = A4 = ramtop + 1
       CMPA.L  (A1),A1
       BNE.S   L00184
       ADDA.L  #$00010000,A4
       BRA.S   L00172

L00184 MOVEQ   #$00,D0   * first writing value
       MOVEQ   #-$01,D1   * second value
       MOVEQ   #-$01,D7   * first colour (white)
L0018A LEA     $00020000,A3  * screenmemory
       MOVEA.L A3,A5
       MOVEA.L D0,A1
       LEA     $1FE4(A1),A2
       SF      -$7F9D(A3)    * initialise sv.jbmax
L0019C CMPA.L  A1,A2
       BNE.S   L001A2        * test whole memory
       MOVEA.L D0,A1

* the ramtes is performed by pokeinig different values in RAM
* and afterwars testing, whether they are still present.
* Sine this is done very fast, only very bad RAM could be detected.
* IBM-compatibles test only for one value
* the questione remains unanswered : what's the use of all this
* shorttime tests. Better: a separate Ram-test prog that tests
* thoroughfully.
* You could as well live without this shorttest.
* The only part of RAM, that should be set to 0 when booting are the 
* systemvariables.
*
L001A2 MOVE.L  (A1)+,D2
       TST.B   D7          * second time only with one value
       BEQ.S   L001C2
       MOVE.L  D0,(A5)     * pokeing
       CMP.L   (A5),D0     * peeking
       BNE.S   L0015C      * Ramerror
       MOVE.L  D1,(A5)
       CMP.L   (A5),D1
       BNE.S   L0015C      * Ramerror
       MOVE.L  D2,(A5)
       CMP.L   (A5)+,D2
       BNE.S   L0015C      * Ramerror
       CMPA.L  A5,A4
       BNE.S   L0019C
       LSL.W   #8,D7
       BRA.S   L0018A

L001C2 CMP.L   (A5),D2
       BNE.S   L0015C      * Ramerror
       CLR.L   (A5)+
       CMPA.L  A4,A5
       BNE.S   L0019C
       MOVE.L  #XL04A74,A1  * Startadress of BASIC
       LEA     $00028000,A6 * Startadress of sysvars
       LEA     $0480(A6),A7 * top of suerivsor-stack
       LEA     $00018020,A3   * statusregister of 8049
       MOVE.B  #$08,$0043(A3) * initialise 8049 to mode 8
       SF      -$001E(A3)
       MOVE.L  #$061F0000,(A3)  * initialise MDV
       MOVE.B  #$1F,$0001(A3)
       MOVE.B  #$01,-$001D(A3)
       MOVE.B  #$C0,$0035(A6)
       JSR     L02C50(PC)       * stop mdv-motor
       MOVE.W  #$D254,(A6)      * mark start of RAM
       MOVE.L  A5,$0020(A6)     * A5=Ramtop
       SUBA.L  #$00000000,A5    * !!! this makes hardly a sense
* might be, that there was a change intended to have different
* values for ramtop and base of resident procs
       MOVE.L  A5,$001C(A6)     * base of resident procs
       MOVE.L  A5,$0014(A6)     * base of transient procs
       MOVE.L  $0020(A6),D0     * !!! look for previous comment !!
* as the ROM is now A5 still is the same as 20(A6) but if value
* of A5 would have been changed this was correct.
       SUB.L   A6,D0            * ramtop-$2800 /64
       LSR.L   #6,D0
       MOVEA.L A7,A3            * A3 = pointer ro supervisor stack
       LEA     $0054(A6),A4     * A4 = SV.BPNT
       BSR.S   L00250           * initialise table of slave-blocks
       LSR.L   #1,D0
       ADD.L   D0,$0054(A6)
       LSR.L   #2,D0            * D0 now ramtop-$2800/512
       ADDI.L  #$20,D0
       CMPI.W  #$01E0,D0        * compare wit 480
       BLS.S   L00246           * if less - use that value
       MOVE.W  #$01E0,D0        * if more: use only 480 (=$1E0)
L00246 BSR.S   L00250           * init job table
       MULU    #$0003,D0        * initalise table of channels
       BSR.S   L00250
       BRA.S   L0025C

L00250 MOVE.L  A3,(A4)+         * initialising-routine
       MOVE.L  A3,(A4)+
       ADDA.W  D0,A3
       MOVE.L  A3,(A4)+
       ADDQ.W  #4,A4
       RTS

L0025C MOVE.L  A3,D0    * init system variables
       SUB.L   A6,D0
       LSR.L   #6,D0
       MOVEA.L D0,A4
       ADDA.L  A7,A4
       MOVEA.L $005C(A6),A3  * A3 = pointer to top of slave-blocks
       MOVE.W  #$0200,D1   * !!! the shortform of this two commands:
       LSR.W   #6,D1     * !!! MOVE.W #8,D1 - since I don't know
* another part in ROM calling this routine MOVEQ #8,D1 was better
       SUBA.W  D1,A3     * !!! best: SUBQ.W #8,A3 / A3 = SV.BTPNT
       MOVEQ   #$01,D0
L00274 MOVE.B  D0,(A4)   * PLACE 0100 0000 0000 0000 in all
       ADDQ.W  #8,A4     * slaveblock tables
       CMPA.L  A3,A4
       BLT.S   L00274
       MOVEA.L $0068(A6),A4  * SV.JBBAS base of Job table
       MOVEA.L $007C(A6),A3  * SV.JBTOP
       MOVEQ   #-$01,D0
L00286 MOVE.B  D0,(A4)       * place FF00 0000 0000 0000 in all
       ADDQ.W  #4,A4         * job and channel tables
       CMPA.L  A3,A4
       BLT.S   L00286
       MOVE.L  A3,$0004(A6)  * SV.CHEAP
       MOVE.L  A3,$000C(A6)  * SV.FREE
       MOVEA.L $001C(A6),A4  * SV.RESPR
       LEA     -$0200(A4),A4 * ADRESS IF RAMTOP-512
       MOVE.L  A4,$0010(A6)  * BASE OF BASIC STACK
       LEA     L02CF8(PC),A5 * start of polled task
       MOVE.L  A5,$003C(A6)  * SV.PLIST
       LEA     L01202(PC),A5
       MOVE.L  A5,$0040(A6)  * SV.SHLIST
       LEA     L00AC0(PC),A5 * pointer to device drivers
       MOVE.L  A5,$0044(A6)
       
       LEA     L01230(PC),A5 * !!! pointer to dir drivers must be
       MOVE.L  A5,$0048(A6)  * omitted or changed when removing MDVs !!
       
       ADDQ.B  #1,$0037(A6)  * network station nr. default 1
       ADDQ.B  #8,$0034(A6)  * mode 8
       ADDQ.B  #1,$00A0(A6)  * ULA TRANSMIT MODE
       ADDQ.W  #1,$00A8(A6)  * SV.TIMVOV baud rate=9600
       MOVE.W  #$001E,$008C(A6)  * autorepeat delay
       ADDQ.W  #2,$008E(A6)  * autorepeat frequency
       ADDQ.W  #3,$0092(A6)  * 
       MOVE.L  $BFE6,$014A(A6)   * BOOT-MESS ETC.
       MOVE.L  $BFE2,$0146(A6)   * TRA-TABELLE
       MOVEA.L $0068(A6),A4  * SV.JBBAS
       MOVE.L  A4,$0064(A6)  * SV.JBPNT
       MOVEA.L $0014(A6),A3  * SV.TRNSP
       CLR.L   -(A3)         * RAMTOP = 0
       MOVEA.L $0010(A6),A0  * SV.BASIC
       MOVE.L  A0,(A4)       * ADRESS OF JOB 0: BASIC
       MOVE.B  #$20,$0013(A0)  * jobs priority increment
       MOVE.L  A3,USP        * pointer of userstack=ramtop-4
       LEA     $0068(A0),A6  * SV.JBBAS 
       MOVEA.L A3,A5 
       SUBA.L  A6,A5         * a5 = zone for basic
       MOVE.W  #$0000,SR     * now user-mode
       JMP     (A1)          * A1 = XL04A74=BASIC-START
*                              find init roms, display F1/F2, do basic

LTRAP0 ADDQ.W  #2,A7         * decrement user stack
       RTS
       
XLTRAP0 EQU LTRAP0
LTRAP1 BSR.S   L00336      * initialise A5 and A6
       BRA     L00460      * Trap 1 continues
XLTRAP1 EQU LTRAP1
LTRAP2 BSR.S   L00336      * initialise A5 and A6
       BRA     L032A2      * Trap2 continues
XLTRAP2 EQU LTRAP2        
LTRAP3 BSR.S   L00336      * initialise A5 and A6
       BRA     L0337C      * Trap3 continues
XLTRAP3 EQU LTRAP3 
LTRAP4 BSR.S   L00336      * initialise A5 and A6
       BRA     L03432      * Trap4 continues
XLTRAP4 EQU LTRAP4

L00336 SUBQ.W  #8,A7       * initialise of A5 and A6
       MOVE.L  $0008(A7),-(A7)
       MOVEM.L D7/A5-A6,$0004(A7)
       MOVEA.L #$00028000,A6
       LEA     $0004(A7),A5
       MOVEQ   #$7F,D7
       AND.L   D7,D0
       RTS

L00352 MOVEM.L D7/A5-A6,-(A7)       *#: ext2int entry
XL00352 EQU L00352
       MOVEA.L A7,A5
       MOVEA.L #$00028000,A6
       MOVE.B  $00018021,D7
       LSR.B   #1,D7
       BCS     L02ABC
       LSR.B   #1,D7
       BCS     L02CCC               * 8049 interrupt
       LSR.B   #1,D7
       BCS     L02CD8
       LSR.B   #1,D7
       BCS     L00900               * do poll loop
       LSR.B   #1,D7
       BCC.S   L003A0
       MOVEM.L D0-D6/A0-A4,-(A7)
       MOVEQ   #$00,D0
       MOVEA.L $0038(A6),A0        * interrupt list
       JSR     L00A9E(PC)          * execute interrupt tasks
       MOVE.B  $0035(A6),D7
       ORI.B   #$10,D7
       MOVE.B  D7,$00018021
       MOVEM.L (A7)+,D0-D6/A0-A4
L003A0 BRA     L003B6              * rte

*#: ret from syscall, clear d0
L003A4 MOVEQ   #$00,D0
*#: ret from syscall
L003A6 BTST    #$05,$000C(A7)  * was it supervisor-mode?
       BNE.S   L003B6
       TST.W   $0030(A6)       * time for a scheduler rerun?
       BNE     L00936
L003B6 MOVEM.L (A7)+,D7/A5-A6
       RTE
       
* returns bas addr. of JOB in A0
*#: D1 jobid(-1)<>A0 base, D1 jobid
L003BC TST.W   D1           * test D1 Job's ID
       BGE.S   L003D8 
       MOVE.L  $0064(A6),D1  * SV.JBPNT
       MOVEA.L D1,A0
       MOVEA.L (A0),A0       * start adress
       SUB.L   $0068(A6),D1  * SV.JBBAS
       LSR.L   #2,D1
       SWAP    D1
       MOVE.W  $0010(A0),D1  * TAG for JOB
       SWAP    D1
L003D6 RTS

L003D8 BSR.S   L003E4  * is valid job?
       BEQ.S   L003D6
       MOVEQ   #-$02,D0  * invalid job
       ADDQ.W  #4,A7
       BRA.L   L003A6  * return

* D1= jobid
* returns JOB.BASE in a0, ^Z flag if fails
L003E4 CMP.W   $0062(A6),D1   * SV.JBMAX
       BHI.S   L003D6
       MOVEA.W D1,A0
       ADDA.W  A0,A0
       ADDA.W  A0,A0
       ADDA.L  $0068(A6),A0  * SV.JBBAS
       TST.B   (A0)
       BLT.S   L003D6
       MOVEA.L (A0),A0
       SWAP    D1
       CMP.W   $0010(A0),D1    * TAG for JOB
       BNE.S   L003D6
       SWAP    D1
       CMP.B   D1,D1
       RTS

* returns ID of CURRENT JOB in in D0
*         base adress in A3
*#: > D0= currjob_id, A3= currjob base
L00408 MOVEA.L $0064(A6),A3  * pointer to current job
       MOVE.L  A3,D0
       SUB.L   $0068(A6),D0  * SV.JBBAS
       LSR.W   #2,D0
       MOVEA.L (A3),A3
       SWAP    D0
       MOVE.W  $0010(A3),D0
       SWAP    D0
       RTS

* initialise transmission through 8049

L00420 MOVE.B  D0,-(A7)
L00422 SUBQ.W  #1,$00A6(A6) * timeout for switching
       BLT.S   L00432
       MOVE.W  #$208B,D0
L0042C DBF     D0,L0042C
       BRA.S   L00422

L00432 CLR.W   $00A6(A6)      * reset timeout
       ANDI.B  #$E7,$00A0(A6)
       MOVE.B  (A7)+,D0
       OR.B    D0,$00A0(A6)
       ANDI.B  #$7F,$0035(A6)
L00448 MOVE.B  $00A0(A6),$00018002
       RTS

* stop transmission through 8049

L00452 BCLR    #$04,$00A0(A6)
       ORI.B   #$80,$0035(A6)
       BRA.S   L00448


* trap 1  jump according to D0

L00460 CMPI.W  #$0024,D0
       BHI.S   L004BC
       MOVE.W  D0,D7
       ADD.W   D7,D7
       MOVE.W  L00472(PC,D7.W),D7
       JMP     ADUMMY(PC,D7.W)
       
L00472        
ADUMMY EQU L00472-$12
       
       DC.W    XLtr1d00-L00460
       DC.W    XLtr1d01-L00460
       DC.W    XLtr1d02-L00460
o78    DC.W    XLtr1d03-L00460
       DC.W    XLtr1d04-L00460
o7c    DC.W    XLtr1d05-L00460
o7e    DC.W    XLtr1d06-L00460
o80    DC.W    XLtr1d07-L00460
       DC.W    XLtr1d08-L00460
       DC.W    XLtr1d09-L00460
       DC.W    XLtr1d0a-L00460
       DC.W    XLtr1d0b-L00460
o8A    DC.W    XLtr1d0c-L00460
       DC.W    XLtr1d0d-L00460
       DC.W    XLtr1d0e-L00460
o90    DC.W    XLtr1d0f-L00460
       DC.W    XLtr1d10-L00460
       DC.W    XLtr1d11-L00460
       DC.W    XLtr1d12-L00460
       DC.W    XLtr1d13-L00460
       DC.W    XLtr1d14-L00460
       DC.W    XLtr1d15-L00460
oA0    DC.W    XLtr1d16-L00460
       DC.W    XLtr1d17-L00460
       DC.W    XLtr1d18-L00460
       DC.W    XLtr1d19-L00460
       DC.W    XLtr1d1a-L00460
       DC.W    XLtr1d1b-L00460
       DC.W    XLtr1d1c-L00460
       DC.W    XLtr1d1d-L00460
       DC.W    XLtr1d1e-L00460
       DC.W    XLtr1d1f-L00460
       DC.W    XLtr1d20-L00460
       DC.W    XLtr1d21-L00460
       DC.W    XLtr1d22-L00460
       DC.W    XLtr1d23-L00460
       DC.W    XLtr1d24-L00460

* If D0=3 or >$25   bad parameter
TR1d03
L004BC MOVEQ   #-$0F,D0
       BRA     L003A6
XLtr1d03  EQU TR1d03

* Info on QDOS
TR1d00
XLtr1d00 EQU TR1d00
o4C2   MOVEQ   #-$01,D1   * get Job-ID
       JSR     L003BC(PC)
       MOVE.L  $BFF6,D2   * D2 = Nr. of version
       MOVEA.L A6,A0
       BRA     L003A4

* Install new table of error messages or tra table
* D2 = adress of error messages or 0
* D1 = adress of tra-table or 0,1
TR1d24
XLtr1d24  EQU TR1d24
o4D4   TST.L   D2
L004D6 BEQ.S   L004EA       * no new message table
       BTST    #$00,D2      * test odd adress
       BNE.S   L0051E       * bad parameter
       MOVEA.L D2,A0
       CMPI.W  #$4AFB,(A0)  * starts with identifier
       BNE.S   L0051E       * errorend
       MOVE.L  A0,$014A(A6) * set new adress
L004EA CLR.B   $0144(A6)    * 
       TST.L   D1           * new tra-table ?
       BEQ.S   L00518       * no: end
       CMPI.L  #$0001,D1    * is it TRA 1
       BNE.S   L00500       * take adress from BFE2       
       MOVE.L  $BFE2,D1     * ADRESSE VON TRA-TABELLE
L00500 BTST    #$00,D1      * odd adress?
       BNE.S   L0051E
       MOVEA.L D1,A0
       CMPI.W  #$4AFB,(A0)  * starts with identifier
       BNE.S   L0051E        * errorend
       MOVE.B  #$01,$0144(A6) * set 
       MOVE.L  A0,$0146(A6)
L00518 MOVEQ   #$00,D0
       BRA     L003A6

L0051E MOVEQ   #-$0F,D0     * bad parameter
       BRA     L003A6

* info on JOB
TR1d02
XLtr1d02  EQU TR1d02
o524   JSR     L003BC(PC) * returns in d1 JOB-ID in a0 addr
       MOVEQ   #$00,D3
       TST.W   $0014(A0)  * JOB status
       BEQ.S   L00532
       MOVEQ   #-$01,D3
L00532 MOVE.B  $0013(A0),D3  * jobs priority increment
       MOVE.L  D2,D0
       MOVE.L  A0,-(A7)
       JSR     L006C6(PC)
       MOVEA.L (A7)+,A0
       MOVE.L  $0008(A0),D2  * owner of job
       LEA     $0068(A0),A0  * prog-start of job
       BRA     L003A4

* create new job
* mt.cjob
TR1d01
XLtr1d01 EQU TR1d01
o54C   TST.L   D1          * identifier<>0
       BEQ.S   L00554
       JSR     L003BC(PC)  * get a0 base
L00554 MOVEM.L D1-D3/A1-A4,-(A7)
       MOVEQ   #$00,D7
       MOVEA.L $0068(A6),A4  * SV.JBBAS
L0055E TST.B   (A4)        * free entry ?
       BLT.S   L00570      * initalise
       ADDQ.W  #1,D7
       ADDQ.W  #4,A4       * next job
       CMPA.L  $006C(A6),A4 * too far
       BLT.S   L0055E       * try next table entry
       MOVEQ   #-$02,D0     * job table too small
       BRA.S   L005E0

* activate job

L00570 MOVEQ   #$68,D1
       ADD.L   D2,D1      * add size of jobs descriptor to length
       ADD.L   D3,D1
       JSR     L02FFA(PC) * reserve d1 Bytes
       BNE.S   L005E0
       MOVEM.L (A7),D1-D3/A1
       MOVE.L  A0,(A4)

* !!! from now on D1-D3,A0-A4 COULD BE USED without problems - see
* end of routine - but only A0 is used !!!

       CMP.W   $0062(A6),D7  * jobnr < highest jobnr?
       BLS.S   L0058C        * old job
       MOVE.W  D7,$0062(A6)  * new job
L0058C ADDQ.W  #4,A0         * a0=jobbas+4
       MOVEQ   #$18,D0       * set job descriptor to 0
L00590 CLR.L   (A0)+
       DBF     D0,L00590
       SUBA.W  #$0060,A0     * again start of job
       MOVE.L  D1,(A0)
       ADDQ.W  #8,A0
       SWAP    D7
       MOVE.W  $0060(A6),D7   * SV.JBTAG current value of job
       MOVE.W  D7,(A0)
       SWAP    D7
       ADDQ.W  #1,$0060(A6)    * increment value of SV.JBMAX
       MOVE.L  $0050(A6),$000C(A0) * pointer to trap redirection table
       ADDA.W  #$0040,A0
       MOVE.L  D2,(A0)+        * length of job
       ADD.L   D2,D3           * + data-aera
       MOVE.L  D3,(A0)+
       MOVEQ   #$10,D0
       ADD.L   A0,D0           * D0 = base of job's prog
       MOVE.L  D0,(A0)+
       ADD.L   D0,D3           * d3 = total length
       EXG     D3,A0
       CLR.L   -(A0)
       EXG     D3,A0
       MOVE.L  D3,(A0)
       ADDQ.W  #6,A0           * start of prog
       MOVE.L  A1,D3
       BEQ.S   L005D4
       MOVE.L  D3,D0
L005D4 MOVE.L  D0,(A0)
       MOVE.L  D0,-$005E(A0)
       LEA     $0006(A0),A0    * start of prog-aera
       MOVEQ   #$00,D0
L005E0 MOVEM.L (A7)+,D1-D3/A1-A4
       MOVE.L  D7,D1
       BRA     L003A6

TR1d04
XLtr1d04 EQU TR1d04
o5EA   JSR     L003BC(PC)    * returns bas addr. in A0; ID in D1
       MOVE.L  D1,D0
L005F0 TST.B   $0013(A0)  * jobs priority increment
       BNE     L006C0        * 'not complete'
       JSR     L006C6(PC)    * look for next job in tree
       TST.L   D1
       BNE.S   L005F0        *   ... for all jobs in tree
       MOVE.L  D0,D1         * restore D1 (JOB-ID)
* none active so far, fall through

* mt.frjob
TR1d05
XLtr1d05 EQU TR1d05
       JSR     L003BC(PC)    * returns bas addr. in A0
       MOVE.L  D1,D0         * IOB-ID
       BEQ     L006C0        * BASIC? 'not complete'
       MOVEA.W D1,A1
       ADDA.W  A1,A1
       ADDA.W  A1,A1
       ADDA.L  $0068(A6),A1  * find table entry
L00616 ADDQ.B  #1,(A1)       * mark table entry
       JSR     L006C6(PC)    * find next job in tree
       TST.L   D1
       BNE.S   L00616        *      ... while any job in tree

       SF      -(A7)         * flag: jobid -1 removed?
       MOVEQ   #$00,D1       * now scan the marked jobs
       MOVEA.L $0068(A6),A1   * SV.JBBAS
L00628 ADDQ.W  #4,A1          * next table entry
       ADDQ.W  #1,D1          * next job nr
       CMP.W   $0062(A6),D1   * SV.JBMAX
       BHI     L006B6
       TST.B   (A1)           * marked ?
       BLE.S   L00628         * no ->
       SF      (A1)           * clear mark
       MOVEA.L (A1),A0
       SWAP    D1
       MOVE.W  $0010(A0),D1    * TAG for JOB
       SWAP    D1
       CMPA.L  $0064(A6),A1  * SV.JBPNT
       BNE.S   L0064C
       ST      (A7)          * set if removed jobid=-1
L0064C TST.B   $0017(A0)     * JOB.WFLAG
       BEQ.S   L00670
       MOVE.L  $0018(A0),D0  * D0 = ID of waiting JOB
       EXG     D0,D1
       JSR     L003E4(PC)    *     get its base, Z flag
       EXG     D1,D0
       BNE.S   L00670        *     ... invalid job
       CMPI.W  #$FFFE,$0014(A0)  * is it really waiting ?
       BNE.S   L00670
       CLR.W   $0014(A0)      *    release it
       MOVE.L  D3,$0020(A0)   *    JOB.D0 = error code
       
* now free jobs resources

L00670 MOVEA.L $0004(A6),A0     * base of common heap
L00674 CMP.L   $0008(A0),D1     * owner of this ?
       BNE.S   L0069A
       MOVEM.L D1/D3/A0-A1,-(A7)
       MOVE.L  $000C(A0),D1
       BEQ.S   L00688
       MOVEA.L D1,A1
       ST      (A1)             * set flag on release
L00688 MOVEA.L $0004(A0),A1
       LEA     -$0018(A1),A3
       MOVEA.L $000C(A1),A1         * dev_close
       JSR     (A1)                 * close channel or release memory
       MOVEM.L (A7)+,D1/D3/A0-A1
L0069A ADDA.L  (A0),A0
       CMPA.L  $000C(A6),A0  * SV.FREE
       BLT.S   L00674        * try next block

       MOVEM.L D1/D3/A1,-(A7)
       MOVEA.L (A1),A0
       JSR     L0308C(PC)      * RELEASE headerblock + program space
       MOVEM.L (A7)+,D1/D3/A1
       ST      (A1)            * invalidate table entry
       BRA     L00628          * remove some more jobs

L006B6 TST.B   (A7)+
       BEQ     L003A4          * return
       BRA     L0093A          * must run through scheduler(job -1 removed)

L006C0 MOVEQ   #-$01,D0        * 'not complete'
       BRA     L003A6

* look for ID of next JOB in tree

L006C6 MOVE.L  D1,D2         * D2 = owner job
       MOVEQ   #$00,D1
L006CA ADDQ.W  #1,D1
       CMP.W   $0062(A6),D1   * SV.JBMAX
       BGT.S   L006E0         * -> try next branch
       BSR.S   L006EE         * get Job base
       TST.B   (A1)           * valid entry?
       BLT.S   L006CA
       CMP.L   $0008(A0),D2   * child of JOB ?
       BEQ.S   L00700
       BRA.S   L006CA         * continue searching

L006E0 CMP.W   D2,D0            * setup for next branch
       BEQ.S   L006FC
       MOVE.W  D2,D1
       BSR.S   L006EE
       MOVE.L  $0008(A0),D2     * owner of JOB
       BRA.S   L006CA           * continue searching

L006EE MOVEA.W D1,A1
       ADDA.W  A1,A1
       ADDA.W  A1,A1
       ADDA.L  $0068(A6),A1  * SV.JBBAS
       MOVEA.L (A1),A0       * a0 = base of JOB
       RTS

L006FC MOVEQ   #$00,D1
       RTS

L00700 SWAP    D1
       MOVE.W  $0010(A0),D1    * get job TAG
       SWAP    D1
       RTS

* mt.trapv set for this job the trap vectors
TR1d07
XLtr1d07 EQU TR1d07

o70A   JSR     L003BC(PC)    * returns bas addr. of JOB in A0
       SUBA.W  #$0054,A1
       MOVE.L  A1,$0050(A6)  * pointer to current trap redir. table
       MOVE.L  A1,$001C(A0)  *        ...   jobs     ...
       BRA     L003A4


* allocate area in a heap
TR1d0c
XLtr1d0c EQU TR1d0c
o71E   ADDA.L  $0008(A5),A0  * a0=pointer to pointer to free space
       JSR     L03104(PC)    * MM.ALLOC
       SUBA.L  $0008(A5),A0  * base of allocated area
       BRA.S   L007A2

* link free space
TR1d0d
XLtr1d0d EQU TR1d0d
o72C   ADDA.L  $0008(A5),A0
       ADDA.L  $0008(A5),A1
       JSR     L03162(PC)    * MM.LINKFR
       BRA.S   L007A2

* allocate common heap area       
TR1d18 
XLtr1d18 EQU TR1d18
L0073A EXG     D2,D1
       JSR     L003BC(PC)    * returns bas addr. in A0, ID in d1
       MOVE.L  D1,-(A7)
       MOVEQ   #$10,D1
       ADD.L   D2,D1        * d2= number of bytes
       JSR     L02FAE(PC)   * allocate memory
       BNE.S   L007BC
       ADDQ.W  #4,A0
L0074E
       MOVE.L  XL0075A,(A0)+   * pseudo driver adress
       MOVE.L  (A7)+,(A0)+     * job id
       CLR.L   (A0)+
       BRA.S   L00766  * !!! there: BRA L003A4


L0075A DC.L    L0305E    * adress for release of heap
XL0075A EQU L0075A-$0C   * that's the value, we need

* release area in common heap
L0075E
TR1d19
XLtr1d19 EQU TR1d19
       LEA     -$0010(A0),A0    * TAG for JOB
       JSR     L0305E(PC)     * MT.RECHP
L00766 BRA     L003A4

* allocation (d0=E) and release (d0=F) of resident proc area
TR1d0e
TR1d0f
XLtr1d0e EQU TR1d0e
XLtr1d0f EQU TR1d0e
L0076A MOVEA.L $001C(A6),A0    * SV.RESPR
       CMPA.L  $0014(A6),A0    * SV.TRNSP 
       BNE.S   L007A0
       CMPI.B  #$0F,D0
       BEQ.S   L00786
       TST.L   D1
       BLE.S   L00766
       JSR     L02FFA(PC)    * reserve d1 bytes
       BLT.S   L007BE
       BRA.S   L00792

L00786 MOVE.L  $0020(A6),D1    * SV.RAMT
       SUB.L   $001C(A6),D1    * SV.RESPR
       JSR     L0308C(PC)      * RELEASE MEMORY
L00792 MOVE.L  $0014(A6),$001C(A6)   * SV TRNSP ½ SV.RESPR
       CLR.L   $0018(A6)       * SV.TRNFR
       BRA     L003A4
L007A0 MOVEQ   #-$01,D0    * 'not complete'
L007A2 BRA.S   L007BE    * !!! Faster: Jump direct - used to save space

* allocate Basic prog aera
TR1d16
XLtr1d16 EQU TR1d16
L007A4 JSR     L031B8(PC)     * allocate memory
       BRA.S   L007BE         * !!! there: BRA L003A6 
* Faster: Jump direct - used to save space

* Release Basic Prog Aera 
TR1d17
XLtr1d17 EQU TR1d17
       MOVE.L  $0014(A6),-(A7)   * SV TRNSP
       SUB.L   D1,$0014(A6)      * SV TRNSP
       JSR     L031C8(PC)        * Release memory
       MOVE.L  (A7)+,$0014(A6)   * SV TRNSP
       BRA.S   L007BE         * !!! memory saving but time waisting
L007BC ADDQ.W  #4,A7
L007BE BRA     L003A6

* set or read display mode according to D1 and D2 ½ Adder
TR1d10
XLtr1d10 EQU TR1d10
o7C0   MOVE.B  $0034(A6),D0     * SV.MCSTA
       TST.B   D1               * read?
       BLT     L0085E           * yes
       ANDI.B  #$F7,D0    * !!! this and next command used for security
       ANDI.B  #$08,D1    * if calling routine did set word
* 'cause all use moveq... not necessary
       OR.B    D1,D0
       MOVE.B  D0,$0034(A6)  * set SV.MCSTA
       MOVE.B  D0,$00018063  * set 8049 according
       MOVE.L  A6,-(A7)      * preserves A6
       MOVE.W  #$1FFF,D0
L007E6 CLR.L   -(A6)         * now cls of whole screen
       DBF     D0,L007E6
       MOVEA.L (A7)+,A6
       
* reinitialisation of screen channels

       MOVEA.L $0078(A6),A4  * SV.CHBAS
L007F2 MOVE.L  (A4)+,D0
       MOVEM.L D1-D6/A0-A6,-(A7)
       BLT.S   L00852        * channel closed?
       MOVEA.L D0,A0
       CMPI.L  #L00D36,$0004(A0)  * is it no screen channel
       BNE.S   L00852        * look for next channels
       MOVE.B  D1,-(A7)
       MOVE.W  $0020(A0),-(A7)
       MOVEQ   #$00,D2
       JSR     L01AFC(PC)    * set border
       LEA     $0036(A0),A1  * paper colour masque
       LEA     $0044(A0),A5  * paper colour byte
       MOVEQ   #$02,D0
L0081C MOVE.B  (A5)+,D1
       JSR     L027D8(PC)    * set paper masque
       ADDQ.W  #4,A1
       DBF     D0,L0081C
       JSR     L01CAE(PC)    * cls
       MOVE.B  (A5),D1
       MOVE.W  (A7)+,D2
       JSR     L01AF8(PC)    * set set border
       SUBQ.W  #5,A5
       ANDI.B  #$00,(A5)    * set char-attributes to 0
       MOVE.L  #$0006000A,$0026(A0) * reset charsize
       TST.B   (A7)+
       BEQ.S   L0084E       * mode 4 ½ yes
       BSET    #$06,(A5)+   * mode 8
       LSL     $0026(A0)
L0084E TST.B   (A5)         * cursor-status
       SNE     (A5)
L00852 MOVEM.L (A7)+,D1-D6/A0-A6
       CMPA.L  $007C(A6),A4  * all channels checked
       BLT.S   L007F2        * no, continue
       BRA.S   L00862

L0085E MOVEQ   #$08,D1
       AND.B   D0,D1         * if mode 4: D1=0, else: D1=8
L00862 TST.B   D2
       BGE.S   L0086A
       MOVE.B  $0032(A6),D2  * SV.TVMOD
L0086A MOVE.B  D2,$0032(A6)
       BRA     L003A4

TR1d11
XLtr1d11 EQU TR1d11

* send command to 8049

L00872 MOVEM.L D4/D6/A0-A1/A3,-(A7)
       JSR     L02C72(PC)    * execute command to 8049
       MOVEM.L (A7)+,D4/D6/A0-A1/A3
       BRA     L003A4
 
TR1d12
XLtr1d12 EQU TR1d12

* MT.BAUD

L00882 MOVEM.L D2/D6/A0-A2,-(A7)
       LEA     L008D6(PC),A0    * table of baudrates
       MOVEQ   #$07,D2
L0088C CMP.W   (A0)+,D1         * compare table with selecte rate
       BEQ.S   L0089E           * match
       DBF     D2,L0088C
       MOVEQ   #-$0F,D0         * no valid baudrate
L00896 MOVEM.L (A7)+,D2/D6/A0-A2
       BRA     L003A6

L0089E MOVE.L  #$4B0,D0         * dezimal 1200
       DIVU    D1,D0            * d0=$4b0/baudrate
       ADDQ.W  #1,D0
       MOVE.W  D0,$00A8(A6)    * SV.TIMOV
       ORI.W   #$0700,SR
       JSR     L02F6E(PC)      * returns D6=6  A0=$18020  A1=$18003
       LEA     $00A0(A6),A2    * SV.TMODE
       ANDI.B  #$F8,(A2)
       OR.B    D2,(A2)
       MOVE.B  (A2),-$0001(A1)
       MOVEQ   #$0D,D0        * cammand 0D = serial settings
       JSR     L02F7C(PC)     * command for 8079
       MOVE.B  D2,D0
       JSR     L02F7C(PC)     * command for 8079
       ANDI.W  #$F8FF,SR
       MOVEQ   #$00,D0
       BRA.S   L00896

L008D6 DC.L    $004B012C        *   75 / 300 BAUD
       DC.L    $025804B0        *  600 /1200 BAUD
       DC.L    $096012C0        * 2400 /4800 BAUD
       DC.L    $25804B00        * 9600 /19200 BAUD

TR1d1a
TR1d1c
TR1d1e
TR1d20
TR1d22
XLtr1d1a EQU TR1d1a
XLtr1d1c EQU TR1d1a
XLtr1d1e EQU TR1d1a
XLtr1d20 EQU TR1d1a
XLtr1d22 EQU TR1d1a       
* link traps
L008E6 ADD.W   D0,D0
       LEA     $04(A6,D0.W),A1
       JSR     L039DC(PC)    * UT.LINK
       BRA.S   L008FC


TR1d1b
TR1d1d
TR1d1f
TR1d21
TR1d23
XLtr1d1b EQU TR1d1b
XLtr1d1d EQU TR1d1b
XLtr1d1f EQU TR1d1b
XLtr1d21 EQU TR1d1b
XLtr1d23 EQU TR1d1b

* task linking traps

L008F2 ADD.W   D0,D0
       LEA     $02(A6,D0.W),A1
       JSR     L039E2(PC)    * UT.UNLNK
L008FC BRA     L003A4


* polled interrupt
L00900 ADDQ.W  #1,$0030(A6)    * SV.POLLM
       BVC.S   L0090A
       SUBQ.W  #1,$0030(A6)
L0090A MOVEM.L D0-D6/A0-A4,-(A7)
       MOVEQ   #-$08,D0
       MOVEQ   #$01,D3
       MOVEA.L $003C(A6),A0    * SV.PLIST
       JSR     L00A9E(PC)      * execute poll tasks
       MOVEM.L (A7)+,D0-D6/A0-A4
       MOVE.B  $0035(A6),D7    * SV.PCINT
       ORI.B   #$08,D7
       MOVE.B  D7,$00018021
       BTST    #$05,$000C(A7)  * supervisor mode?
       BNE     L003B6          * yes -> rte
* else fall through into scheduler
L00936 JSR     L009D4(PC)      * save jobs data
L0093A MOVE.W  $0030(A6),D3    * SV.POLLM
       CLR.W   $0030(A6)
       ADDQ.W  #1,$002E(A6)    * SV.RAND
       MOVEQ   #-$10,D0
       MOVEA.L $0040(A6),A0    * SV.SHLST
       JSR     L00A9E(PC)      * execute sched tasks
       JSR     L00A0C(PC)      * get highest job priority
       TST.L   D0
       BLT.S   L0093A        * no runnable job ->
       MOVE.L  D0,$0064(A6)  * SV.JBPNT: new current job
       JSR     L00A78(PC)    * execute it
       
TR1d08 
XLtr1d08 EQU TR1d08
* suspend job
       JSR     L003BC(PC)    * returns bas addr. in A0
       MOVE.W  D3,$0014(A0)  * JOB status
       MOVE.L  A1,$000C(A0)
       MOVEQ   #$00,D0
       BRA.L   L00936
       
TR1d09
XLtr1d09 EQU TR1d09
* reactivate job
       JSR     L003BC(PC)    * returns bas addr. in A0
       TST.W   $0014(A0)  * JOB status
       BEQ.S   L0098A
       CLR.W   $0014(A0)  * JOB status
       MOVE.L  $000C(A0),D0  * Adder S. 337
       BEQ.S   L0098A
       MOVEA.L D0,A0
       SF      (A0)
L0098A MOVEQ   #$00,D0
       BRA.L   L00936

TR1d0b
XLtr1d0b EQU TR1d0b
* change priority of job
o990   JSR     L003BC(PC)    * returns bas addr. in A0
       MOVE.B  D2,$0013(A0)  * jobs priority increment
       BNE.S   L009CA
       SF      $0012(A0)     * Jobs accumulated priority
       BRA.S   L009CA

TR1d0a
XLtr1d0a EQU TR1d0a
* activate job
o9A0   JSR     L003BC(PC)    * returns bas addr. in A0
       TST.B   $0013(A0)     * jobs priority increment
       BNE.S   L009D0
       MOVE.B  D2,$0013(A0)  * jobs priority increment
       MOVE.L  $0004(A0),$0062(A0)  * START ½ Adder S. 335
       TST.W   D3            * wait ?
       BEQ.S   L009CA        * no ->
       ST      $0017(A0)
       JSR     L00408(PC)
       MOVE.L  D0,$0018(A0)  * JOB.WJOB
       MOVE.W  #$FFFE,$0014(A3)
L009CA MOVEQ   #$00,D0
L009CC BRA     L00936

L009D0 MOVEQ   #-$01,D0
       BRA.S   L009CC

* scheduler aux subroutines

* save jobs registers into jobheader
L009D4 MOVE.L  A6,-(A7)
       MOVEA.L $0064(A6),A6  * SV.JBPNT
       MOVEA.L (A6),A6
       TST.B   $0012(A6)     * accumulated priority
       BEQ.S   L009E8
       MOVE.B  #$01,$0012(A6)
L009E8 MOVEM.L D0-D7/A0-A4,$0020(A6) * save regs into jobheader
       MOVE.L  (A5)+,$003C(A6)    * D7
       MOVE.L  (A5)+,$0054(A6)    * a5
       MOVE.L  (A5)+,$0058(A6)    * a6
       MOVE.L  USP,A0             * a7
       MOVE.L  A0,$005C(A6)       *
       MOVE.W  (A5)+,$0060(A6)    * SR
       MOVE.L  (A5)+,$0062(A6)    * PC
       MOVEA.L (A7)+,A6
       RTS

* get job with highest priority
* D0=-2 if none ready
L00A0C MOVEQ   #-$02,D0
       MOVEQ   #$00,D1
       MOVEA.L $0064(A6),A2   * SV.JBPNT
       MOVEA.L A2,A4          * a4= current job
       MOVE.W  $0062(A6),D2   * SV.JBMAX
       LSL.W   #2,D2
       MOVEA.L $0068(A6),A3   * SV.JBBAS
       ADDA.W  D2,A3

L00A22 ADDQ.W  #4,A2          * a2= currently examined job
       CMPA.L  A3,A2          * >SV.JBMAX ?
       BLE.S   L00A2C
       MOVEA.L $0068(A6),A2   *  ... wrap search
L00A2C TST.B   (A2)           * valid job ?
       BLT.S   L00A72         * no ->
       MOVEA.L (A2),A0
       TST.B   $0013(A0)    * jobs priority increment
       BEQ.S   L00A72       * 0 -> no chance
       TST.W   $0014(A0)    * JOB status
       BEQ.S   L00A54       * -> runnable
       BLT.S   L00A72       * -> indefintely suspended, try next
       SUB.W   D3,$0014(A0)  * decrement timeout by SV.POLLM
       BGT.S   L00A72        * -> still suspended
       CLR.W   $0014(A0)     * make sure it doesn't get suspended by accident
       MOVE.L  $000C(A0),D2  * JOB.HOLD
       BEQ.S   L00A54
       MOVEA.L D2,A1         * release flag
       SF      (A1)
L00A54 MOVE.B  $0012(A0),D2     * Jobs accumulated priority
       BEQ.S   L00A64
       ADD.B   $0013(A0),D2     * jobs priority increment
       BCC.S   L00A66
       ST      D2
       BRA.S   L00A66

L00A64 MOVEQ   #$01,D2
L00A66 MOVE.B  D2,$0012(A0)    * Jobs accumulated priority
       CMP.B   D1,D2
       BLS.S   L00A72          * no chance
       MOVE.L  A2,D0           * best so far
       MOVE.B  D2,D1           * ...         priority
L00A72 CMPA.L  A4,A2
       BNE.S   L00A22
       RTS

* return from scheduler and run job
L00A78 MOVEA.L $0064(A6),A0  * SV.JBPNT
       MOVEA.L (A0),A0
       ADDA.W  #$0016,A7
       MOVE.L  $0062(A0),-(A7)          * JOB.PC
       MOVE.W  $0060(A0),-(A7)          * JOB.SR
       MOVE.L  $001C(A0),$0050(A6)      * SV.TRAPV <- JOB.TRAPV
       MOVEA.L $005C(A0),A1
       MOVE.L  A1,USP                   * JOB.A7
       MOVEM.L $0020(A0),D0-D7/A0-A6
       RTE

*  execute linked tasks (extint,poll,sched)
*  A0= list
L00A9E MOVE.W  D0,-(A7)
L00AA0 MOVEA.L A0,A3
       ADDA.W  (A7),A3        * offset to driver address
       MOVE.L  A0,-(A7)
       BEQ.S   L00ABC
       MOVE.W  D3,-(A7)
       ANDI.W  #$007F,D3
       MOVEA.L $0004(A0),A0   * A0=adress of task
       JSR     (A0)
       MOVE.W  (A7)+,D3
       MOVEA.L (A7)+,A0
       MOVEA.L (A0),A0
       BRA.S   L00AA0

L00ABC ADDQ.L  #6,A7
       RTS

* 'SER' driver
L00AC0 DC.L    L00C88   * pointer to next driver in link
       DC.L    L00BB6   * adress of in / out
       DC.L    L00AD0   * adress to open chan
       DC.L    L00B8E   * adress to close 

L00AD0 SUBQ.W  #8,A7
       MOVEA.L A7,A3
       JSR     L0372C(PC)   * IO.DECODE
       BRA.S   L00B20       * ERROR
       BRA.S   L00B20       * ERROR
       BRA.S   L00B28       * SUCCESS

L00ADE DC.W    $0003
       DC.B    'SER'
       DC.B    $00
       DC.W    $0004   * 4 parameters
       DC.W    $FFFF   * default values
       DC.W    $0001   * = ser1
       DC.W    $0004   * 4 options for second parameter
       DC.B    'OEMS'
       DC.W    $0002   * 2 options for third
       DC.B    'IH'
       DC.W    $0003   * 3 options for fourth
       DC.B    'RZC',$00
L00AFA DC.L    $02000000   * values for 8049 - open ser1
       DC.L    $00000100 
       DC.L    $03000000   * OPEN SER2
       DC.L    $00000100
L00B0A DC.L    $04000000   * close ser1
       DC.L    $00000100
       DC.L    $05000000   * close ser2
       DC.L    $00000100
               
L00B1A MOVEQ   #-$07,D0   * 'not found'
       BRA.S   L00B20
        
L00B1E MOVEQ   #-$09,D0   * 'in use'
L00B20 ADDQ.W  #8,A7
       ANDI.W  #$F8FF,SR
       RTS

* open ser
        
L00B28 ORI.W   #$0700,SR
       MOVE.W  (A7),D4
       BLE.S   L00B1A
       SUBQ.W  #2,D4
       BGT.S   L00B1A
       LEA     $0098(A6),A5    * SV.SER1C
       LEA     L00AFA(PC),A4   * is it a serial channel
       BLT.S   L00B42          * no½ look for next channel
       ADDQ.W  #4,A5
       ADDQ.W  #8,A4
L00B42 MOVE.L  (A5),D0
       BEQ.S   L00B56
       MOVEA.L D0,A0
       SUBA.W  #$0020,A0
       BCLR    #$07,$0082(A0)
       BNE.S   L00B6A
       BRA.S   L00B1E

L00B56 MOVE.W  #$00E4,D1
       JSR     L02FAE(PC) * MM.ALCHP
       BNE.S   L00B20
       MOVEQ   #$51,D1
       LEA     $0082(A0),A2
       JSR     L037F4(PC)     * IO.QSET
L00B6A MOVEQ   #$51,D1
       LEA     $0020(A0),A2   * pointer to buffer
       JSR     L037F4(PC)     * IO.QSET
       MOVE.L  A2,(A5)
       MOVE.L  (A7),$0018(A0)
       MOVE.L  $0004(A7),$001C(A0)
       SUBQ.W  #1,$001C(A0)
       SUBQ.W  #2,$001E(A0)
       BSR.S   L00BAA
       MOVEQ   #$00,D0
       BRA.S   L00B20

L00B8E LEA     L00B0A(PC),A4  * close ser
       BTST    #$01,$0018(A0) * input queue
       BEQ.S   L00B9C
       ADDQ.L  #8,A4
L00B9C BSR.S   L00BAA
       LEA     $0082(A0),A2  *
       JSR     L03888(PC)    * IO.QEOF
       MOVEQ   #$00,D0
       RTS

L00BAA 
       MOVE.L  A0,-(A7)   * serial I/O
       MOVEA.L A4,A3
       JSR     L02C72(PC)    * execute command to 8049
       MOVEA.L (A7)+,A0
       RTS

L00BB6 JSR     L0388C(PC)    * IO.SERIO
       DC.l    L00BC8        * test ser
       DC.L    L00C24        * read from ser
       DC.L    L00BD0        * write to ser
       RTS

L00BC8 LEA     $0020(A0),A2 * pointer to buffer
       JMP     L0380A(PC)   * IO.QTEST
       
* what kind of ser-transmission is to do?

L00BD0 CMPI.B  #$0A,D1
       BNE.S   L00BDE
       TST.B   $001F(A0)
       BLE.S   L00BDE
       MOVEQ   #$0D,D1
L00BDE MOVE.W  $001A(A0),D0
       MOVE.B  L00BEA(PC,D0.W),D0
       JMP     L00BEA(PC,D0.W)  * now its done

L00BEA DC.B    XWNOPAR-L00BEA
       DC.B    XWODD-L00BEA
       DC.B    XWEVEN-L00BEA
       DC.B    XWBIT7-L00BEA
       DC.B    XWBIT8-L00BEA
       
WBIT7  BSET    #7,D1
XWBIT7 EQU WBIT7
WNOPAR
XWNOPAR EQU WNOPAR
L00BF4 LEA     $0082(A0),A2
       TST.B   $0144(A6)
       BEQ.S   L00C0C
       MOVE.L  A3,-(A7)
       MOVEA.L $BFEE,A3   * !!! PROG-LABEL
       JSR     (A3)
       MOVEA.L (A7)+,A3
       BRA.S   L00C74

L00C0C JSR     L03838(PC)    * IO.QIN
       BRA.S   L00C74

WBIT8  BCLR    #$07,D1
       BRA.S   L00BF4
XWBIT8 EQU WBIT8
WODD   BSR.S   L00C76
       BCHG    #$07,D1
       BRA.S   L00BF4
XWODD EQU WODD
WEVEN  BSR.S   L00C76
       BRA.S   L00BF4
XWEVEN EQU WEVEN
L00C24 LEA     $0020(A0),A2  * pointer to buffer
       JSR     L0385E(PC)    * IO.QOUT
       BNE.S   L00C74
       MOVE.W  $001A(A0),D3
       MOVE.B  L00C3A(PC,D3.W),D3
       JMP     L00C3A(PC,D3.W)

L00C3A DC.B    XRNOPAR-L00C3A  * displacement for read-ser
       DC.B    XRIMPAR-L00C3A
       DC.B    XRPAR-L00C3A
       DC.B    XRBIT71-L00C3A
       DC.B    XRBIT70-L00C3A
       DC.B    $00

RBIT71 BCHG    #$07,D1
       BRA.S   L00C4C

RIMPAR BCHG    #$07,D1
RPAR   BSR.S   L00C76
RBIT70
L00C4C BTST    #$07,D1
       BEQ.S   L00C54
       MOVEQ   #-$0D,D0
L00C54
RNOPAR

XRBIT71 EQU RBIT71
XRIMPAR EQU RIMPAR
XRPAR   EQU RPAR
XRBIT70 EQU RBIT70
XRNOPAR EQU RNOPAR

       TST.B   $0144(A6)
       BEQ.S   L00C66
       MOVE.L  A3,-(A7)
       MOVEA.L $BFEA,A3
       JSR     (A3)
       MOVEA.L (A7)+,A3
L00C66 CMPI.B  #$0D,D1
       BNE.S   L00C74
       TST.B   $001F(A0)
       BLE.S   L00C74
       MOVEQ   #$0A,D1
L00C74 RTS

L00C76 MOVEQ   #$06,D3
       MOVE.B  D1,D4
L00C7A ROR.B   #1,D1
       EOR.B   D1,D4
       DBF     D3,L00C7A
       ROXL.B  #1,D4
       ROXR.B  #1,D1
       RTS

* 'PIPE' driver
L00C88 DC.L    L00D36   * pointer to next driver
       DC.L    L037CC   * addr. for pipe I/O
       DC.L    L00C98   * addr. to open pipe#
       DC.L    L00D0A   * addr. to close pipe#
       
L00C98 SUBQ.W  #2,A7    * open pipe#
       MOVEA.L A7,A3
       JSR     L0372C(PC)   * IO.DECODE
       BRA.S   L00D00       * ERROR
       BRA.S   L00D00       * ERROR
       BRA.S   L00CB2       * SUCCESS

o00CA6 DC.W    $0004
       DC.B    'PIPE'
       DC.W    $0001   * 1 parameter
       DC.B    ' _'    * '_' necessary
       DC.W    $0000   * lenght parameter
       
L00CB2 MOVE.W  (A7),D1       * any length ?
       BEQ.S   L00CD2
       ADDI.W  #$31,D1
       JSR     L02FAE(PC)    * MM.ALCHP
       BNE.S   L00D00
       MOVE.W  (A7),D1
       ADDQ.W  #1,D1
       LEA     $0020(A0),A2   * pointer to buffer
       JSR     L037F4(PC)     * IO.QSET
       MOVE.L  A2,$001C(A0)
       BRA.S   L00CFE         * done

* connect to another pipe
L00CD2 MOVEA.W D3,A2          * chan id
       ADDA.L  A2,A2
       ADDA.L  A2,A2
       ADDA.L  $0078(A6),A2
       MOVEA.L (A2),A2        * chan base
       CMPI.L  #L00C88,$0004(A2)  * is it a pipe channel ?
       BNE.S   L00D04             * no ½ error
       MOVE.L  A2,-(A7)           * save its base
       MOVEQ   #$20,D1
       JSR     L02FAE(PC)   *  MM.ALCHP
       MOVEA.L (A7)+,A2
       BNE.S   L00D00        * -> no mem
       LEA     $0020(A2),A2  * pointer to queue
       MOVE.L  A0,(A2)       * link queues
       MOVE.L  A2,$0018(A0)
L00CFE MOVEQ   #$00,D0
L00D00 ADDQ.W  #2,A7
       RTS

L00D04 MOVEQ   #-$0F,D0
       ADDQ.W  #2,A7
       RTS

* close
L00D0A TST.L   $0018(A0)
       BNE.S   L00D1C
       LEA     $0020(A0),A2  * pointer to buffer
       TST.L   (A2)          * queue empty?
       BEQ.S   L00D32        * yes: close channel
       JMP     L03888(PC)    * IO.QEOF

L00D1C MOVE.L  $0018(A0),-(A7)
       BSR.S   L00D32        * close channel
       MOVEA.L (A7)+,A2
       LEA     -$0020(A2),A0
       TST.B   (A2)     * file empty
       BLT.S   L00D32   * yes: close channel
       CLR.L   (A2)
       MOVEQ   #$00,D0
       RTS

L00D32 JMP     L0305E(PC)    * MT.RECHP

* 'CON' driver
L00D36 DC.L    L01104   * ADRESS ON NEXT LINKED DRIVER
       DC.L    L00E76   * I/O OF CON AND SER
       DC.L    L00D46   * OPEN CON OR SER
       DC.L    L00E3A   * CLOSE CON OR SER
       
L00D46 SUBA.W  #$000A,A7
       MOVEA.L A7,A3
       JSR     L0372C(PC)   * IO.DECODE
       BRA.S   L00D9E       * ERROR
       BRA.S   L00DC8       * ERROR
       BRA.S   L00D72       * SUCCESS

o00D56 DC.W    $0003
       DC.B    'CON'
       DC.B    $00
       DC.W    $0005   * 5 parameters
       DC.W    $205F   * needs '_'
       DC.W    448     * wide
       DC.W    $2058   * needs 'X'
       DC.W    180     * high
       DC.W    $2041   * needs 'A' 
       DC.W    32      * x-origin
       DC.W    $2058   * needs 'X'
       DC.W    16      * y-origin
       DC.W    $205F   * needs '_'
       DC.W    $0080   * default buffer:128 Bytes
        
L00D72 MOVEQ   #$7A,D1     * initialise
       ADD.W   $0008(A7),D1
       BSR.S   L00DCE   * open #
       BNE.S   L00DC8   * out of memory
       LEA     $0068(A0),A2   * initialise keyboard buffer
       SUBI.W  #$0078,D1
       JSR     L037F4(PC)     * IO.QSET
       MOVEA.L $004C(A6),A3
       MOVE.L  A3,D3
       BNE.S   L00D98      * if buffer exists: create new one
       MOVE.L  A2,(A2)   
       MOVE.L  A2,$004C(A6)  * store addr of keyboard buffer
       BRA.S   L00DC6

L00D98 MOVE.L  (A3),(A2)   * link buffer-adresses
       MOVE.L  A2,(A3)
       BRA.S   L00DC6      * back without error

L00D9E JSR     L0372C(PC)   * IO.DECODE
       BRA.S   L00DC8       * ERROR
       BRA.S   L00DC8       * ERROR
       BRA.S   L00DC0       * SUCCESS

o00DA8 DC.W    $0003
       DC.B    'SCR',$00
       DC.W    $0004   * 4 parameters
       DC.W    $205F   * needs '_'
       DC.W    448     * wide 
       DC.W    $2058   * needs 'X'
       DC.W    180     * high
       DC.W    $2041   * needs 'A'
       DC.W    32      * x-origin
       DC.W    $2058   * needs 'X'
       DC.W    16      * y-origin


* open screen channel       
L00DC0 MOVEQ   #$6C,D1 * lenght of description
       BSR.S   L00DCE  * open channel
       BRA.S   L00DC8

L00DC6 MOVEQ   #$00,D0
L00DC8 ADDA.W  #$000A,A7
       RTS

* open channel
L00DCE JSR     L02FAE(PC)          * MM.ALCHP
       BNE.S   L00E38
       MOVE.W  D1,-(A7)
       LEA     $0026(A0),A2
       MOVE.L  #$0006000A,(A2)+    * charsize:  6x10 pixels
       MOVE.L  #XL0AD9A,(A2)+      * PIXEL-SCR
       MOVE.L  #XL0B106,(A2)+      * PIXEL-SCR
       MOVE.L  #$00020000,(A2)+    * SCREENMEMORY
       MOVE.W  #$80,$64(A0)        * necessary ? lenght of buffer?
       LEA     $003E(A0),A1        * define paper
       MOVEQ   #$04,D1
       MOVE.B  D1,$0046(A0)
       JSR     L027D8(PC)
       MOVE.L  #$08076400,$56(A0)   * graphic shell
       BTST    #$03,$0034(A6)       * SV.MCSTA - mode 4 ?
       BEQ.S   L00E20
       ADDQ.W  #6,$0026(A0)         * adapt size
       BSET    #$06,$0042(A0)
L00E20 MOVEQ   #$00,D2
       LEA     $0006(A7),A1
       JSR     L01AB6(PC)
       MOVE.W  (A7)+,D1
       TST.L   D0          * error ?
       BEQ.S   L00E38      * no
       MOVE.L  D0,-(A7)
       JSR     L0305E(PC)  * MT.RECHP
       MOVE.L  (A7)+,D0    * report
L00E38 RTS

L00E3A LEA     $0068(A0),A3   * CLOSE CON / SER
       TST.L   (A3)
       BEQ.S   L00E70
       MOVEA.L (A3),A2
       CMPA.L  A2,A3
       BNE.S   L00E4E
       CLR.L   $004C(A6)      * SV.KEYQ
       BRA.S   L00E70

L00E4E CMPA.L  $004C(A6),A3   * SV.KEYQ
       BNE.S   L00E66
L00E54 TST.B   -$0025(A2)
       BNE.S   L00E62
       CMPA.L  (A2),A3
       BEQ.S   L00E62
       MOVEA.L (A2),A2
       BRA.S   L00E54

L00E62 MOVE.L  A2,$004C(A6)  * SV.KEYQ
L00E66 MOVEA.L A3,A2
L00E68 MOVEA.L (A2),A2
       CMPA.L  (A2),A3
       BNE.S   L00E68
       MOVE.L  (A3),(A2)
L00E70 JSR     L0305E(PC)    * MT.RECHP
       RTS

L00E76 TST.B   $0033(A6)     * I/O OF CON/SER screen freezed
       BEQ.S   L00E80
       MOVEQ   #-1,D0        * not complete
       RTS

L00E80 CMPI.B  #$07,D0
       BHI.S   L00EFC
       MOVEQ   #-1,D7
       MOVEQ   #$00,D6
       MOVE.W  D2,D5
       MOVE.L  D1,D4
       MOVEA.L A1,A4
       LEA     $0068(A0),A5
       TST.L   D3
       BLT.S   L00EB0
       CMPI.B  #$04,D0
       BHI.S   L00EB0
       TST.L   (A5)
       BEQ.S   L00EEC
       MOVEA.L $004C(A6),A2    * SV.KEYQ
       TST.B   -$0025(A2)
       BNE.S   L00EB0
       MOVE.L  A5,$004C(A6)
L00EB0 MOVE.B  L00EB8(PC,D0.W),D0
       JMP     L00EB8(PC,D0.W)

L00EB8 DC.B   L00EC0-L00EB8   * test pending input
       DC.B   L00EC6-L00EB8   * put byte
       DC.B   L00F54-L00EB8
       DC.B   L00ECA-L00EB8   * edit line
       DC.B   L00F5A-L00EB8
       DC.B   L00F00-L00EB8   * 
       DC.B   L00EEC-L00EB8   * not used
       DC.B   L00EDE-L00EB8   * put in queue

*------------ general scr I/O       

L00EC0 JMP     L0380A(PC)     * IO.QTEST

L00EC6 MOVEA.L A5,A2         * A2=buffer adress of keyboard
       JMP     L0385E(PC)    * IO.QOUT

L00ECA MOVEQ   #$00,D0
L00ECC CMP.W   D4,D5         * all chars printed
       BLS.S   L00EEE
       MOVEA.L A5,A2
       JSR     L0385E(PC)    * IO.QOUT
       BLT.S   L00EEE
       MOVE.B  D1,(A4)+
       ADDQ.W  #1,D4
       BRA.S   L00ECC

L00EDE MOVEQ   #$00,D0
       CMP.W   D4,D5
       BLS.S   L00EEE
       MOVE.B  (A4)+,D1
       BSR.S   L00F00
       ADDQ.W  #1,D4
       BRA.S   L00EDE

L00EEC MOVEQ   #-$0F,D0
L00EEE MOVE.W  D4,D1
       MOVEA.L A4,A1
L00EF2 BCLR    #$07,$0042(A0)
       RTS

L00EFA MOVEQ   #$05,D0   * add one character to screen
L00EFC JMP     L01992(PC)

L00F00 MOVEQ   #$00,D0
       CMPI.B  #$0A,D1     * CR ?
       BEQ.S   L00F36      * add new line
       TST.B   $0048(A0)   * new line status ½Adder S. 337
       BEQ.S   L00F14      * position cursor
       MOVE.B  D1,-(A7)    * byte to send on stack
       BSR.S   L00F46      * position cursor
       MOVE.B  (A7)+,D1
L00F14 BSR.S   L00EFA      * put byte
       BEQ.S   L00F44      * succeeded ½ end
       MOVE.W  $0026(A0),D0 * if not: increment cursor
       ADD.W   D0,$0022(A0)
       BTST    #$07,$0042(A0)
       BNE.S   L00F42
       MOVE.B  D0,$0048(A0)
       TST.B   $0043(A0)    * cursoff ?
       BEQ.S   L00F42   * end
       BSR.S   L00F46   * position cursor
       BRA.S   L00F42

L00F36 TST.B   $0048(A0) * is curosr at end of line?
       BGE.S   L00F3E
       BSR.S   L00F46   * position cursor
L00F3E ST      $0048(A0)
L00F42 MOVEQ   #$00,D0
L00F44 RTS

* position cursor
L00F46 TST.B   $0043(A0)   * new line - cursor activ
       BLE.S   L00F50      * no
       JSR     L01BA2(PC)  * test position
L00F50 JMP     L01BF8(PC)  * if necessary: NL

L00F54 TST.L   D3
       BEQ.S   L00F6C
       BRA.S   L00F5E

*----------------- Line editor
        
L00F5A MOVEQ   #-$01,D4    
       MOVE.W  D1,D4
L00F5E SWAP    D1
       MOVE.W  D1,D6    * d6=position of cursor
       SUBA.W  D4,A4    * position cursor in buffer
       ADDA.W  D6,A4
       BNE.S   L00F84   * end of buffer
       TST.L   D3
       BLT.S   L00F84
L00F6C TST.B   $0043(A0)    * curson ?
       BLE.S   L00F76
       JSR     L01BA2(PC)   * position cursor ..
L00F76 JSR     L01BF2(PC)   * if neccessary to start
       BSR     L010DC       * of next line
       MOVE.W  D4,D6
       SUB.W   D3,D6
       SUBA.W  D3,A4
L00F84 MOVE.B  $43(A0),-(A7)
L00F88 MOVEA.L A5,A2         * keyboard buffer
       JSR     L0385E(PC)    * IO.QOUT get byte
       BLT     L01018        * EOF ?
       TST.B   $43(A0)       * cursor activ
       BLE.S   L00FA0
       MOVE.B  D1,-(A7)      * received byte
       JSR     L01BA2(PC)    * position cursor
       MOVE.B  (A7)+,D1
L00FA0 CMPI.B  #$0A,D1       * CR?
       BEQ.S   L01002
       CMPI.B  #$1F,D1       * less 31 - do nothing
       BLS.S   L00F88
       CMPI.B  #$BF,D1   * higher 191 - append square
       BHI.S   L00FDA
       MOVE.W  D4,D0   * d4 = length of line
       SUB.W   D6,D0   * actual position
       BRA.S   L00FBE   * store byte

L00FB8 MOVE.B  $00(A4,D0.W),$01(A4,D0.W)   * line out
L00FBE DBF     D0,L00FB8
       ADDQ.W  #1,D6
       ADDQ.W  #1,D4      * correct pointer
       MOVE.B  D1,(A4)+   * store bytes
       MOVEQ   #-$01,D7
       BSR     L010AC
       BSR     L010CE     * scroll ?
       CMP.W   D4,D5
       BHI.S   L00F88     * more bytes editable
       MOVEQ   #-$05,D0   * "buffer full "
       BRA.S   L01022

L00FDA TST.L   D4
       BGE.S   L00FEA
       CMPI.B  #$D0,D1   * cursor up
       BEQ.S   L01002
       CMPI.B  #$D8,D1   * down
       BEQ.S   L01002
L00FEA SUBI.B  #$C0,D1   * left
       BEQ.S   L01030
       SUBQ.B  #2,D1     * ctrl-left
       BEQ     L0107C
       SUBQ.B  #6,D1     * right
       BEQ.S   L01038
       SUBQ.B  #2,D1     * ctrl-right
       BEQ     L01080
L01000 BRA.S   L00F88    * position cursor

L01002 MOVE.B  D1,-(A7)   * output of line - cursor up/down
       MOVEQ   #-$01,D7
       BSR     L010E0
       MOVE.B  (A7)+,(A4)+
       ADDQ.W  #1,D4
       JSR     L01B94(PC)
       BSR     L00F36
       BRA.S   L0102A

L01018 TST.B   (A7)   * end of edit
       BLT.S   L01022
       JSR     L01B86(PC)
       MOVEQ   #-$01,D0
L01022 SUBA.W  D6,A4
       ADDA.W  D4,A4
       MOVE.W  D6,D1
       SWAP    D1
L0102A ADDQ.W  #2,A7
       BRA     L00EEE

L01030 
       BSR.S   L01054   * cursor left previous line ?
       BEQ.S   L01000   * pos. cursor
L01034 ADDQ.W  #1,D6
       BRA.S   L01000
        
L01038 
       ADDQ.W  #1,D6   * cursor right
       CMP.W   D4,D6
       BHI.S   L01050   * end of buffer?
       ADDQ.W  #1,A4
       JSR     L01C48(PC)   * pos cursor right
       BEQ.S   L01000
       JSR     L01BF8(PC)
       BSR     L010CE
       BRA.S   L01000

L01050 SUBQ.W  #1,D6
L01052 BRA.S   L01000

L01054 SUBQ.W  #1,D6   * previous line to edit
       BLT.S   L0107A
       JSR     L01C3E(PC)
       BEQ.S   L01078
       JSR     L01C56(PC)
       BNE.S   L010DA
       MOVE.W  $001C(A0),D0
       DIVU    $0026(A0),D0
       SUBQ.W  #1,D0
       MULU    $0026(A0),D0
       MOVE.W  D0,$0022(A0)
       MOVEQ   #$00,D0
L01078 SUBQ.W  #1,A4
L0107A BRA.S   L010DA

L0107C BSR.S   L01054   * delete one char: ctrl-left-right
       BNE.S   L01034
L01080 CMP.W   D6,D4
       BEQ.S   L01052
       SUBQ.W  #1,D4
       MOVE.W  D4,D0
       SUB.W   D6,D0
       MOVE.W  D0,D1
       BRA.S   L01092

L0108E MOVE.B  $0001(A4),(A4)+
L01092 DBF     D0,L0108E
       SUBA.W  D1,A4
       MOVE.L  $0022(A0),-(A7)
       MOVEQ   #$00,D7
       BSR.S   L010E0
       BNE.S   L010A6
       MOVEQ   #$20,D1
       BSR.S   L010AC
L010A6 MOVE.L  (A7)+,D7
       BSR.S   L010D0
       BRA.S   L01052

L010AC BSR     L00EFA   * position cursor
       BEQ.S   L010DA
       JSR     L01C32(PC)
       BEQ.S   L010DA
       TST.W   D7
       BLT.S   L010C8
       SUB.W   $0028(A0),D7
       BGE.S   L010C8
       ADD.W   $0028(A0),D7
       BRA.S   L01100

L010C8 JSR     L01BF8(PC)   * scroll if needed
       BRA.S   L010D8

L010CE BSR.S   L010DC
L010D0 SUBA.W  D4,A4
       ADDA.W  D6,A4
       MOVE.L  D7,$0022(A0)
L010D8 MOVEQ   #$00,D0
L010DA RTS

L010DC MOVE.L  $0022(A0),D7
L010E0 MOVEQ   #$00,D0
       MOVE.W  D4,D3
       SUB.W   D6,D3
       BRA.S   L010F4

L010E8 MOVE.B  (A4)+,D1
       MOVE.W  D3,-(A7)
       BSR.S   L010AC
       MOVE.W  (A7)+,D3
       TST.L   D0
       BNE.S   L010FC
L010F4 DBF     D3,L010E8
       MOVEQ   #$00,D3
       RTS

L010FC ADDA.W  D3,A4
       ADDQ.W  #1,D3
L01100 TST.L   D0
       RTS
        
* ----------End of line editor
        
L01104 DC.L    $0       * nothing left to link
       DC.L    L01186   * I/O net
       DC.L    L01114   * open net#
       DC.L    L01158   * close net#
       
L01114 SUBQ.W  #4,A7
       MOVEA.L A7,A3
       JSR     L0372C(PC)   * IO.DECODE
       BRA.S   L01154       *  ERROR
       BRA.S   L01154       *  ERROR
       BRA.S   L01132       *  SUCCESS

o1122  DC.W    $0003
       DC.B    'NET'
       DC.B    $00
       DC.W    2   * two parameters
       DC.W    2   * initialise to second 
       DC.B    'OI' 
       DC.B    ' _' 
       DC.W    0   * number
       
L01132 MOVE.W  #$120,D1
       JSR     L02FAE(PC)   * MM.ALCHP
       BNE.S   L01154
       MOVE.B  $0003(A7),$0018(A0)
       MOVE.B  $0037(A6),$0019(A0)  * SV.NETNR
       MOVE.B  $0001(A7),$001C(A0)
       SUBQ.B  #2,$001C(A0)
       MOVEQ   #$00,D0
L01154 ADDQ.W  #4,A7
       RTS

L01158 TST.B   $001C(A0)   * close net
       BGE.S   L0117E
       MOVE.B  #$01,$001C(A0)
       MOVE.B  $011F(A0),$001D(A0)
L0116A TST.B   $00EE(A6)   * SV.MDRUN
       BNE.S   L0116A
       MOVE.W  #$0578,D4
L01174 JSR     L05538
       DBEQ    D4,L01174
L0117E JMP     L0305E(PC)    * MT.RECHP

L01182 MOVEQ   #-$0F,D0
       RTS

L01186 JSR     L0388C(PC)    * IO.SERIO for net#

L0118A
       DC.L   L01198       * test byte
       DC.L   L011C4       * read
       DC.L   L011D0       * write
       RTS                 * if error: back

L01198 MOVE.B  $001C(A0),D0   * test byte
       BLT.S   L01182
       MOVEQ   #$00,D2
       MOVE.B  $011F(A0),D2
       MOVE.B  $20(A0,D2.W),D1
       SUB.B   $001D(A0),D2
       BCS.S   L011CC
       TST.B   D0
       BEQ.S   L011B6
       MOVEQ   #-$0A,D0
       RTS

L011B6 SF      $011F(A0)
       JSR     L054A2
       BEQ.S   L01198
       RTS

L011C4 BSR.S   L01198   * read net#
       BNE.S   L011CE
       ADDQ.B  #1,$011F(A0)
L011CC MOVEQ   #$00,D0
L011CE RTS

L011D0 TST.B   $001C(A0)   * write net#
       BGE.S   L01182
       MOVEQ   #$01,D2
       ADD.B   $011F(A0),D2
       BCC.S   L011F8
       MOVE.B  D1,-(A7)
       MOVE.W  #$00FF,$001C(A0)
       JSR     L05538
       MOVE.B  (A7)+,D1
       ST      $001C(A0)
       TST.L   D0
       BNE.S   L011CE
       MOVEQ   #$01,D2
L011F8 MOVE.B  D1,$1F(A0,D2.W)
       MOVE.B  D2,$011F(A0)
       BRA.S   L011CC

L01202 
       DC.L    L02D00   * pointer to list of scheduler tasks
       DC.L    L0120A   * pointer to first task

L0120A MOVE.L  $004C(A6),D4   * SV.KEYQ
       BEQ.S   L0122E
       MOVEA.L D4,A0
       LEA     -$0068(A0),A0
       MOVE.W  $00AA(A6),D4   * SV.FSTAT
       TST.B   $0043(A0)
       BEQ.S   L01228
       SUB.W   D3,D4
       BGT.S   L0122A
       JSR     L01BA2(PC)     * show cursor (flash)
L01228 MOVEQ   #$0C,D4
L0122A MOVE.W  D4,$00AA(A6)   * SV.FSTAT
L0122E RTS

      include flp1_mdv_main

* clock-traps       

TR1d13
TR1d14
TR1d15
XLtr1d13 EQU TR1d13
XLtr1d14 EQU TR1d13
XLtr1d15 EQU TR1d15

L0195A  LEA     $00018000,A0

L01960 MOVE.L  (A0),D2
       CMP.L   (A0),D2
       BNE.S   L01960
       CMPI.B  #$14,D0
       BGT.S   L01972
       BEQ.S   L01974
       MOVE.L  D2,D1
       BRA.S   L0198E

L01972 ADD.L   D2,D1       * adjust
L01974 SF      (A0)+
       MOVEQ   #-$11,D0
       MOVEQ   #$03,D3
L0197A ROL.L   #8,D1
       MOVEQ   #$00,D2
       MOVE.B  D1,D2
       BRA.S   L01984
L01982 MOVE.B  D0,(A0)
L01984 DBF     D2,L01982
       ROR.B   #1,D0
       DBF     D3,L0197A

L0198E BRA     L003A4


***********************
*
* START SCREEN + CON
*
***********************
*
* screen printing routine for trap 3 d0=5 or d0 = [$09 - $36]
* this routine is extremely slow - it should be speeded up
*
***********************

L01992 MOVE.B  $0043(A0),-(A7) * cursor status 
       BLE.S   L019A4       * cursor inactiv
       MOVEM.W D0-D2,-(A7)  * calling params of TRAP 3
       JSR     L01BA2(PC)   * get cursor positon
       MOVEM.W (A7)+,D0-D2
L019A4 CMPI.B  #$05,D0      * is Trap3 d0=5 ?
       BNE.S   L019B0       * no
       JSR     L01A4C(PC)   * execute trap 
       BRA.S   L019CE

L019B0 CMPI.W  #$0036,D0   * d0>36
       BHI.S   L019EE
       CMPI.W  #$0009,D0   * do<9
       BLT.S   L019EE
       BGT.S   L019C2
       JSR     (A2)        * sd.extop: do userroutine
       BRA.S   L019CE

L019C2 ADD.B   D0,D0       * adjust d0 for displacement
       MOVEA.W L019F2-$14(PC,D0.W),A3   * !!!must depend on 19F2
       LSR.L   #1,D0
       JSR     L019f2-$60(PC,A3.W)      * !!! $60=Tr3disp
L019CE TST.B   (A7)+       * test cursor status
       BLE.S   L019E8      * inactiv
       TST.L   D0          * any errors?
       BNE.S   L019E8
       TST.B   $0043(A0)   * again: test cursor status
       BGE.S   L019E8      * inactiv
       MOVEM.L D0-D2,-(A7) * save cursor status
       JSR     L01B86(PC)  * reposition cursor
       MOVEM.L (A7)+,D0-D2
L019E8 TST.L   D0
       RTS

Tr3D1c
Tr3D1d
XTr3D1c EQU Tr3D1c
XTr3D1d EQU Tr3D1c

L019EC ADDQ.L  #4,A7
L019EE MOVEQ   #-$0F,D0
       BRA.S   L019CE

L019F2 
Tr3disp equ L019F2-$60

       DC.W    XTr3D0a-Tr3disp
       DC.W    XTr3D0b-Tr3disp
       DC.W    XTr3D0c-Tr3disp
       DC.W    XTr3D0d-Tr3disp
       DC.W    XTr3D0e-Tr3disp
       DC.W    XTr3D0f-Tr3disp
       DC.W    XTr3D10-Tr3disp
       DC.W    XTr3D11-Tr3disp
       DC.W    XTr3D12-Tr3disp
       DC.W    XTr3D13-Tr3disp
       DC.W    XTr3D14-Tr3disp
       DC.W    XTr3D15-Tr3disp
       DC.W    XTr3D16-Tr3disp
       DC.W    XTr3D17-Tr3disp
       DC.W    XTr3D18-Tr3disp
       DC.W    XTr3D19-Tr3disp
       DC.W    XTr3D1a-Tr3disp
       DC.W    XTr3D1b-Tr3disp
       DC.W    XTr3D1c-Tr3disp
       DC.W    XTr3D1d-Tr3disp
       DC.W    XTr3D1e-Tr3disp
       DC.W    XTr3D1f-Tr3disp
       DC.W    XTr3D20-Tr3disp
       DC.W    XTr3D21-Tr3disp
       DC.W    XTr3D22-Tr3disp
       DC.W    XTr3D23-Tr3disp
       DC.W    XTr3D24-Tr3disp
       DC.W    XTr3D25-Tr3disp
       DC.W    XTr3D26-Tr3disp
       DC.W    XTr3D27-Tr3disp
       DC.W    XTr3D28-Tr3disp
       DC.W    XTr3D29-Tr3disp
       DC.W    XTr3D2a-Tr3disp
       DC.W    XTr3D2b-Tr3disp
       DC.W    XTr3D2c-Tr3disp
       DC.W    XTr3D2d-Tr3disp
       DC.W    XTr3D2e-Tr3disp
       DC.W    XTr3D2f-Tr3disp
       DC.W    XTr3D30-Tr3disp
       DC.W    XTr3D31-Tr3disp
       DC.W    XTr3D32-Tr3disp
       DC.W    XTr3D33-Tr3disp
       DC.W    XTr3D34-Tr3disp
       DC.W    XTr3D35-Tr3disp
       DC.W    XTr3D36-Tr3disp
             
Tr3D05
XTr3D05 EQU Tr3D05
L01A4C JSR     L01BCE(PC)     * trap#3,D0 = 05
       BLT.S   L01A76
       MOVE.B  D1,D2
       MOVE.L  $0018(A0),D0   * window topleftside
       ADD.L   $0022(A0),D0   * cursor position
       MOVE.W  D0,D1
       SWAP    D0
       MOVE.B  $0042(A0),D3   * arguments for printing like
* underline, strip, colour, size etc. are now in D3

       LEA     $003A(A0),A1    * strip colour mask
       MOVEM.L $002A(A0),A2-A3 * font adress
       JSR     L02840(PC)      * prin char
       BRA     L01C48          * cursor-movement
L01A76 RTS

Tr3D0a
XTr3D0a EQU Tr3D0A
L01A78 
       JSR     L01BF2(PC)      * trap#3,D0 = 0A
       MOVE.L  $001C(A0),(A1)
       MOVE.L  $0022(A0),$0004(A1)
       MOVEQ   #$00,D0
       RTS

Tr3D0b
XTr3D0B EQU Tr3D0B
L01A8A 
       BSR.S   L01A78     * trap#3,D0 = 0B
       MOVE.L  D1,-(A7)
       MOVE.W  $0026(A0),D0
       BSR.S   L01AAA
       BSR.S   L01AAA
       SUBQ.W  #6,A1
       MOVE.W  $0028(A0),D0
       BSR.S   L01AAA
       BSR.S   L01AAA
       MOVE.L  (A7)+,D1
       SUBA.W  #$000A,A1
       MOVEQ   #$00,D0
       RTS

L01AAA MOVEQ   #$00,D1
       MOVE.W  (A1),D1
       DIVU    D0,D1
       MOVE.W  D1,(A1)
       ADDQ.W  #4,A1
       RTS

L01AB6  
Tr3D0d
XTr3D0d EQU Tr3D0d
       MOVEM.W D1-D4,-(A7)     * trap#3,D0 = 0D
       JSR     L01C1C(PC)
       MOVEM.W (A1),D0-D3
       EXG     D0,D2
       EXG     D1,D3
       MOVEQ   #$00,D4
       BCLR    D4,D0
       BCLR    D4,D2
       TST.W   D2
       BEQ     L01B64
       TST.W   D3
       BEQ     L01B64
       MOVE.W  D0,D4
       ADD.W   D2,D4
       BCS     L01B64
       CMPI.W  #$0200,D4
       BHI.S   L01B64
       MOVE.W  D1,D4
       ADD.W   D3,D4
       BCS.S   L01B64
       CMPI.W  #$0100,D4
       BHI.S   L01B64
       CLR.W   $0020(A0)
       BRA.S   L01B12

* set border
Tr3D0c
XTr3D0c equ Tr3D0c
L01AF8 MOVE.B  D1,$0047(A0)     * trap#3,D0 = 0C
L01AFC MOVEM.W D1-D4,-(A7)
       CMP.W   $0020(A0),D2
       BEQ.S   L01B0A
       JSR     L01C1C(PC)
L01B0A MOVEM.W $0018(A0),D0-D4
       BSR.S   L01B6C
L01B12 MOVE.W  $0002(A7),D4
       CMPI.W  #$0100,D4
       BHI.S   L01B64
       BSR.S   L01B6E
       MOVEM.W D0-D4,$0018(A0)
       BEQ.S   L01B60
       MOVE.W  (A7),D1
       CMPI.B  #$80,D1
       BEQ.S   L01B60
       MOVEA.L A7,A1
       JSR     L027D8(PC)
       MOVE.W  $001A(A0),D1
       BSR.S   L01B6C
       NEG.W   D4
       EXG     D4,D3
       JSR     L025BE(PC)
       ADD.W   D4,D1
       SUB.W   D3,D1
       JSR     L025BE(PC)
       ADD.W   D3,D1
       SUB.W   D4,D1
       EXG     D4,D3
       ADD.W   D4,D4
       EXG     D4,D2
       JSR     L025BE(PC)
       ADD.W   D4,D0
       SUB.W   D2,D0
       JSR     L025BE(PC)
L01B60 MOVEQ   #$00,D0
       BRA.S   L01B66

L01B64 MOVEQ   #-$04,D0      * 'out of range'
L01B66 MOVEM.W (A7)+,D1-D4
       RTS
        
L01B6C NEG.W   D4
L01B6E ADD.W   D4,D1
       ADD.W   D4,D4
       SUB.W   D4,D3
       BLE.S   L01B82
       ADD.W   D4,D0
       ADD.W   D4,D4
       SUB.W   D4,D2
       BLE.S   L01B82
       ASR.W   #2,D4
       RTS

L01B82 ADDQ.W  #4,A7
       BRA.S   L01B64

Tr3D0e
XTr3D0e EQU Tr3D0e
L01B86 MOVEQ   #$01,D2
       TST.B   $0043(A0)
       BGT.S   L01BCA
       JSR     L01BF2(PC)
       BRA.S   L01BAA

Tr3D0f
XTr3D0f EQU Tr3D0f
L01B94 MOVEQ   #$00,D2
       TST.B   $0043(A0)
       BGT.S   L01BAA
       MOVE.B  D2,$0043(A0)
       BRA.S   L01BCA

L01BA2 MOVE.B  $0043(A0),D2
       BEQ.S   L01BCA
       NEG.B   D2
L01BAA JSR     L01BCE(PC)
       BLT.S   L01BCC
       MOVE.B  D2,$0043(A0)
       MOVE.L  $0018(A0),D0
       ADD.L   $0022(A0),D0
       MOVE.W  D0,D1
       SWAP    D0
       MOVEM.W $0026(A0),D2-D3
       JSR     L02548(PC)
L01BCA MOVEQ   #$00,D0
L01BCC RTS

L01BCE MOVE.L  $0022(A0),D0     * verify cursor in window
       BMI.S   L01BEE
       TST.W   D0
       BMI.S   L01BEE
       ADD.L   $0026(A0),D0
       CMP.W   $001E(A0),D0
       BHI.S   L01BEE
       SWAP    D0
       CMP.W   $001C(A0),D0
       BHI.S   L01BEE
       MOVEQ   #$00,D0
       RTS

L01BEE MOVEQ   #-$04,D0    * out of range
       RTS

Tr3D2f
XTr3D2f EQU Tr3D2f
L01BF2 TST.B   $0048(A0)
       BEQ.S   L01C1A
L01BF8 MOVEM.L D0-D2/A1,-(A7)
       JSR     L01C32(PC)
       BEQ.S   L01C12
       MOVEQ   #$18,D0
       MOVE.W  $0028(A0),D1
       NEG.W   D1
       JSR     L01CBE(PC)
       CLR.W   $0022(A0)
L01C12 SF      $0048(A0)
       MOVEM.L (A7)+,D0-D2/A1
L01C1A RTS

L01C1C CLR.L   $0022(A0)
       BRA.S   L01C9A

Tr3D10
XTr3D10 EQU Tr3D10
       MULU    $0028(A0),D2
       BRA.S   L01C2C

Tr3D11
XTr3D11 EQU Tr3D11
       MOVE.W  $0024(A0),D2
L01C2C MULU    $0026(A0),D1
       BRA.S   L01C6C

Tr3D12
XTr3D12 EQU Tr3D12
L01C32 MOVEQ   #$00,D1
       MOVE.W  $0024(A0),D2
       ADD.W   $0028(A0),D2
       BRA.S   L01C6C

Tr3D13
XTr3D13 EQU Tr3D13
L01C3E MOVE.W  $0022(A0),D1
       SUB.W   $0026(A0),D1
       BRA.S   L01C50

Tr3D14
XTr3D14 EQU Tr3D14
* cursor-movement
L01C48 MOVE.W  $0022(A0),D1
       ADD.W   $0026(A0),D1
L01C50 MOVE.W  $0024(A0),D2
       BRA.S   L01C6C

Tr3D15
XTr3D15 EQU Tr3D15
L01C56 MOVE.W  $0024(A0),D2
       SUB.W   $0028(A0),D2
       BRA.S   L01C68

Tr3D16
XTr3D16 EQU Tr3D16
       MOVE.W  $0024(A0),D2
       ADD.W   $0028(A0),D2
L01C68 MOVE.W  $0022(A0),D1
Tr3D17
XTr3D17 EQU Tr3D17
L01C6C MOVE.W  D1,D0
       BLT.S   L01CA2
       ADD.W   $0026(A0),D0
       CMP.W   $001C(A0),D0
       BHI.S   L01CA2
       MOVE.W  D2,D0
       BLT.S   L01CA2
       ADD.W   $0028(A0),D0
       CMP.W   $001E(A0),D0
       BHI.S   L01CA2
L01C88 BTST    #$03,$0034(A6)   * SV.MCSTA
       BEQ.S   L01C94
       BCLR    #$00,D1
L01C94 MOVEM.W D1-D2,$0022(A0)
L01C9A SF      $0048(A0)
       MOVEQ   #$00,D0
       RTS

L01CA2 MOVEQ   #-$04,D0
       RTS

Tr3D26
XTr3D26 EQU Tr3D26
       MOVEQ   #$00,D0
       LEA     L025D6(PC),A2
       BRA.S   L01CE0

Tr3D20
XTr3D20 EQU Tr3D20
L01CAE JSR     L01C1C(PC)
       MOVEQ   #$20,D0
Tr3D21
Tr3D22
Tr3D23
Tr3D24
XTr3D21 EQU Tr3D21
XTr3D22 EQU Tr3D22
XTr3D23 EQU Tr3D23
XTr3D24 EQU Tr3D24
       SUBI.W  #$0020,D0
       LEA     L025BE(PC),A2
       BRA.S   L01CDC

Tr3D18
Tr3D19
Tr3D1a
XTr3D18 EQU Tr3D18
XTr3D19 EQU Tr3D19
XTr3D1a EQU Tr3D1a
L01CBE SUBI.W  #$0018,D0
       LEA     L025FE(PC),A2
       BRA.S   L01CDC
Tr3D1b
Tr3D1e
Tr3D1f
XTr3D1b EQU Tr3D1b
XTr3D1e EQU Tr3D1b
XTr3D1f EQU Tr3D1b
       SUBI.W  #$001B,D0
       LEA     L02648(PC),A2
       BTST    #$03,$0034(A6)  * SV.MCSTA
       BEQ.S   L01CDC
       BCLR    #$00,D1
L01CDC LEA     $0036(A0),A1
L01CE0 MOVEM.L D4-D5,-(A7)
       MOVE.W  D1,D4
       MOVE.W  D0,D5
       MOVEM.W $0018(A0),D0-D3
       SUBQ.W  #1,D5
       BLT.S   L01D22
       BGT.S   L01CFA
       MOVE.W  $0024(A0),D3
       BRA.S   L01D22

L01CFA ADD.W   $0024(A0),D1
       SUBQ.W  #2,D5
       BGE.S   L01D12
       SUB.W   $0024(A0),D3
       MOVE.W  $0028(A0),D5
       ADD.W   D5,D1
       SUB.W   D5,D3
       BLE.S   L01D24
       BRA.S   L01D22

L01D12 MOVE.W  $0028(A0),D3
       TST.W   D5
       BEQ.S   L01D22
       ADD.W   $0022(A0),D0
       SUB.W   $0022(A0),D2
L01D22 JSR     (A2)
L01D24 MOVEQ   #$00,D0
       MOVEM.L (A7)+,D4-D5
       RTS
Tr3D2e
XTr3D2e EQU Tr3D2e
       LEA     L025BE(PC),A3
       BTST    #$03,$0042(A0)
       BEQ.S   L01D3C
       LEA     L025CA(PC),A3
L01D3C MOVEA.L A1,A2
       SUBQ.W  #4,A7
       MOVEA.L A7,A1
       JSR     L027D8(PC)
       MOVE.L  #$01FF01FF,D3
       BTST    #$03,$0034(A6)  * SV.MCSTA
       BEQ.S   L01D58
       BCLR    #$10,D3
L01D58 MOVEM.L (A2),D0/D2
       EXG     D0,D2
       AND.L   D3,D0
       AND.L   D3,D2
       MOVE.L  D0,D3
       ADD.L   D2,D3
       CMP.W   $001E(A0),D3
       BGT.S   L01D88
       SWAP    D3
       CMP.W   $001C(A0),D3
       BGT.S   L01D88
       ADD.L   $0018(A0),D0
       MOVE.W  D2,D3
       SWAP    D2
       MOVE.W  D0,D1
       SWAP    D0
       JSR     (A3)
       MOVEQ   #$00,D0
L01D84 ADDQ.W  #4,A7
       RTS

L01D88 MOVEQ   #-$04,D0
       BRA.S   L01D84
       
Tr3D25
XTr3D25 EQU Tr3D25
       MOVE.L  A1,D0
       BGT.S   L01D96
       LEA     L0AD9A,A1        * PIXEL F§R SCREEN
L01D96 MOVE.L  A2,D0
       BGT.S   L01DA0
       LEA     L0B106,A2        * PIXEL-ADRESSEN
L01DA0 MOVEM.L A1-A2,$002A(A0)
       MOVEQ   #$00,D0
       RTS

Tr3D27
Tr3D28
Tr3D29
XTr3D27 EQU Tr3D27
XTr3D28 EQU Tr3D28
XTr3D29 EQU Tr3D29
       SUBI.W  #$0027,D0
       MOVE.B  D1,$44(A0,D0.W)
       LSL.W   #2,D0
       LEA     $36(A0,D0.W),A1
       MOVEQ   #$00,D0
       JMP     L027D8(PC)

Tr3D2a
XTr3D2a EQU Tr3D2a
       BTST    #$03,$0034(A6)  * SV.MCSTA
       BEQ     L01E3C
       MOVEQ   #$02,D0
       BRA.S   L01DD4
Tr3D2c
XTr3D2c EQU Tr3D2c
       MOVEQ   #$0C,D0
       LSL.B   #2,D1
       BRA.S   L01E3E
Tr3D2b
XTr3D2b EQU Tr3D2b
       MOVEQ   #$01,D0
L01DD4 TST.B   D1
       SNE     D1
       BRA.S   L01E3E
Tr3D2d
XTr3D2d EQU Tr3D2d
       JSR     L01BF2(PC)
       ANDI.W  #$0003,D1
       ANDI.W  #$0001,D2
       BTST    #$03,$0034(A6)  * SV.MCSTA
       BEQ.S   L01DF2
       BSET    #$01,D1
L01DF2 
       MOVE.B  L01E4E(PC,D1.W),$0027(A0)  * store horizontal increment
       MOVE.B  L01E52(PC,D2.W),$0029(A0)  * vertical increment
       LSL.B   #1,D1
       OR.B    D2,D1
       LSL.B   #4,D1
       MOVEQ   #$70,D0
       BSR.S   L01E3E
       MOVE.W  $0022(A0),D0
       ADD.W   $0026(A0),D0
       CMP.W   $001C(A0),D0
       BLS.S   L01E1A
       JSR     L01BF8(PC)
L01E1A MOVE.W  $0024(A0),D0
       ADD.W   $0028(A0),D0
       CMP.W   $001E(A0),D0
       BLS.S   L01E4A
       MOVEQ   #$18,D0
       MOVEQ   #-$0A,D1
       JSR     L01CBE(PC)
       SUBI.W  #$000A,$0024(A0)
       BGE.S   L01E4A
       CLR.W   $0024(A0)
L01E3C BRA.S   L01E4A

L01E3E AND.B   D0,D1
       NOT.B   D0
       AND.B   D0,$0042(A0)
       OR.B    D1,$0042(A0)
L01E4A MOVEQ   #$00,D0
       RTS

L01E4E DC.L    $06080C10    * 6,8,12,16 pixels
L01E52 DC.W    $0A14        * 10,20 pixels

Tr3D36
XTr3D36 EQU Tr3D36
       LEA     $0018(A1),A4
       JSR     L021DC(PC)
       MOVE.L  L02242(PC),-(A1)
       MOVE.W  L02240(PC),-(A1)
       JSR     L020D8(PC)
       LEA     L01E90(PC),A3
       JSR     L0419E(PC)
       LEA     $0018(A1),A1
       BSR.S   L01E8A
       MOVE.W  (A1)+,D1
       BSR.S   L01E8A
       MOVE.W  $001E(A0),D2
       SUB.W   (A1)+,D2
       BSET    #$07,$0042(A0)
       JMP     L01C88(PC)

L01E8A MOVEQ   #$02,D0
       JMP     L04196(PC)

* table for calculation of pixel-graphics

L01E90 DC.W    $1210
       DC.W    $16EE
       DC.W    $DC0C
       DC.W    $0EFA
       DC.W    $0CFB
       DC.W    $E8E2
       DC.W    $0C0E
       DC.W    $0EF4
       DC.W    $0AF5
       DC.W    $0000

Tr3D34
XTr3D34 EQU Tr3D34
       LEA     $004A(A0),A2
       MOVEQ   #$12,D0
L01EAA MOVE.W  (A1)+,(A2)+
       SUBQ.W  #2,D0
       BNE.S   L01EAA
       RTS

Tr3D35
XTr3D35 EQU Tr3D35
       MOVEA.L A0,A4
       TST.L   D1
       BNE.S   L01EC2
       BSR.S   L01EFA
       MOVE.B  #$00,$0049(A4)
       BRA.S   L01EF4

L01EC2 CMPI.L  #1,D1
       BNE.S   L01EE4
       BSR.S   L01EFA
       MOVE.B  #$01,$0049(A4)
       MOVE.L  #$410,D1
       JSR     L02FAE(PC)   * MM.ALCHP
       BNE.S   L01EF6
       MOVE.L  A0,$005C(A4)
       BRA.S   L01EF4

L01EE4 BTST    #$00,D1
       BEQ.S   L01EF0
       CLR.L   $0060(A4)
       BRA.S   L01EF4

L01EF0 MOVE.L  D1,$0060(A4)
L01EF4 MOVEQ   #$00,D0
L01EF6 MOVEA.L A4,A0
       RTS

L01EFA TST.B   $0049(A4)
       BEQ.S   L01F08
       MOVEA.L $005C(A4),A0
       JSR     L0305E(PC)    * MT.RECHP
L01F08 RTS

Tr3D30
XTr3D30 EQU Tr3D30
       MOVE.L  A4,-(A7)
       LEA     $000C(A1),A4
       MOVE.L  -(A4),-(A1)
       MOVE.L  -(A4),-(A1)
       MOVE.L  -(A4),-(A1)
       MOVEA.L (A7)+,A4
Tr3D31
XTr3D31 EQU Tr3D31
       MOVEM.L A3/A5,-(A7)
       LEA     L01F26(PC),A3
       SUBQ.L  #6,A1
       BRA     L02100

L01F26 DC.W    $0001       !!! displ. for point and line ROUTINE 1
       DC.W    XL01F45-*   !!! LAST ADDR. OF OPERATION TABLE          
       DC.W    XL0205C-*   !!! first routine for calculation
       DC.W    XL01F38-*   !!! ADRESS OF 2. OP. TABLE
       DC.W    XL02136-*   !!! second routine for calcul.

L01F38
XL01F38 EQU L01F38
       DC.L    $DC16D00C
       DC.L    $16161616
       DC.L    $E8F40CBE
       DC.L    $0EFAEE0C
       DC.L    $BE0EDC16
L01F44 DC.B    $16
       DC.B    $00

XL01F45 EQU L01F44+1  !!! TO HAVE LABELS ON EVEN ADDR.


Tr3D32
XTr3D32 EQU Tr3D32
       MOVEM.L A3/A5,-(A7)
       LEA     $0002(A1),A4
       TST.L   (A4)+
       BGT.S   L01F64
       MOVEQ   #$14,D0
       JSR     L04196(PC)
       MOVEM.L (A4)+,D2-D7
       MOVEM.L D2-D4,-(A4)
       MOVEM.L D5-D7,-(A4)
L01F64 LEA     L01F6C(PC),A3
       BRA     L02100

* displacement for arc-routines

L01F6C DC.W    $0003      ROUTINE AND TABLE
       DC.W    XL01F45-*  LAST ADDR OF OPERATION TABLE
       DC.W    XL0205C-*  first calculation routine
of72   DC.W    XL01F7E-*  table of operators
       DC.W    XL01FA8-*  calcul. routine
of76   DC.W    XL01FD0-*  oper. table
       DC.W    XL01FCE-*  calcul rout (RTS)
of7A   DC.W    XL021EA-*  oper. table
       DC.W    XL02136-*  calcul routine

L01F7E 
XL01F7E EQU L01F7E
       DC.W    $FAEE
       DC.W    $0CE2
       DC.W    $C40E
       DC.W    $B810
       DC.W    $D00A
       DC.W    $F4E8
       DC.W    $0C16
       DC.W    $160E
       DC.W    $A616
       DC.W    $0E0A
       DC.W    $E2CA
       DC.W    $101A
       DC.W    $160A
       DC.W    $160E
       DC.W    $1016
       DC.W    $289A
       DC.W    $A6B2
       DC.W    $0A10
       DC.W    $24E2
       DC.W    $CA10
       DC.W    $0C00

L01FA8 
XL01FA8 EQU L01FA8 
       TST.B   -$0058(A4)
L01FAC BMI.S   L01FBC
       MOVE.L  L0224E(PC),-(A1)
       MOVE.W  L0224C(PC),-(A1)
       MOVEQ   #$0A,D0
       BSR     L04196
L01FBC MOVE.L  -$001E(A4),D0
       SWAP    D0
       SUBQ.W  #1,D0
       SWAP    D0
       CMP.L   L0224C(PC),D0
       BLT.S   L01FCE
       CLR.L   D2
L01FCE RTS
XL01FCE  EQU  L01FCE

L01FD0
XL01FD0 EQU L01FD0
       DC.W    $16E2
       DC.W    $0A16
       DC.W    $0A18
       DC.W    $D00A
       DC.W    $A716
       DC.W    $1816
       DC.W    $8E0E
       DC.W    $CA8E
       DC.W    $1016
       DC.W    $B9B3
       DC.W    $881A
       DC.W    $168E
       DC.W    $0E89
       DC.W    $8F94
       DC.W    $9B00

Tr3D33
XTr3D33 EQU Tr3D33
       MOVEM.L A3/A5,-(A7)
       LEA     L01FFC(PC),A3
       BRA     L02100
L01FFA RTS
XL01FFA EQU L01FFA
L01FFC DC.W    $0003    
o1fe   DC.W    XL0200E-*
       DC.W    XL02018-*
o202   DC.W    XL02017-*
       DC.W    XL0205C-*
o206   DC.W    XL0203A-*
       DC.W    XL01FFA-*
o20a   DC.W    XL021EA-*
       DC.W    XL02136-*

L0200E 
XL0200E EQU L0200E
       DC.W    $E812
       DC.W    $E9EE
       DC.W    $EE12
       DC.W    $E80E
       DC.W    $EF00

L02018
XL02017 EQU L02018-1
XL02018 EQU L02018

       CMPI.W  #$0801,(A1)
       ADDQ.W  #6,A1
       BGE.S   L02032
       MOVE.L  #$6487ED51,-(A1)
       MOVE.W  #$0801,-(A1)
       LEA     L02034(PC),A3
       JSR     L0419E(PC)
L02032 RTS

* table for ellipse-operations
L02034 DC.W    $0AEE
       DC.W    $E8EF
       DC.W    $E900
L0203A
XL0203A EQU L0203A
       DC.W    $DCC4
       DC.W    $160A
       DC.W    $E816
       DC.W    $0EEE
       DC.W    $160E
       DC.W    $E21A
       DC.W    $16E8
       DC.W    $0E16
       DC.W    $FA0A
       DC.W    $16FB
       DC.W    $EFE2
       DC.W    $1816
       DC.W    $E80E
       DC.W    $1614
       DC.W    $F40A
       DC.W    $16F5
       DC.W    $E900

L0205C 
XL0205C EQU L0205C
       MOVEM.L D0-D1/A4,-(A7)
       CLR.L   -(A1)
       CLR.W   -(A1)
       MOVEQ   #$01,D0
       ROR.L   #2,D0
       MOVE.W  #$0800,D1
       MOVEQ   #$04,D2
L0206E MOVE.L  D0,-(A1)
       MOVE.W  D1,-(A1)
       ADDQ.W  #1,D1
       DBF     D2,L0206E
       ADDQ.W  #1,(A1)
       LEA     L02252(PC),A3
       MOVEQ   #$08,D2
L02080 MOVE.W  -(A3),-(A1)
       DBF     D2,L02080
       MOVE.W  $001C(A0),-$001A(A6)
       MOVE.W  $001E(A0),-$001E(A6)
       CLR.W   -$001C(A6)
       CLR.W   -$0020(A6)
       MOVE.W  $0018(A0),-$0034(A6)
       MOVE.W  $001A(A0),-$0038(A6)
       CLR.W   -$0036(A6)
       CLR.W   -$003A(A6)
       MOVE.B  $0042(A0),-$0023(A6)
       MOVE.B  $0049(A0),-$0032(A6)
       MOVE.L  $005C(A0),-$002A(A6)
       MOVE.L  $0060(A0),-$002E(A6)
       MOVEQ   #$01,D2
       BSR.S   L020D8
       LEA     L020EE(PC),A3
       BSR     L0419E
       MOVEM.L (A7)+,D0-D1/A4
       RTS

L020D8 MOVE.W  $001E(A0),-(A1)
       SUBQ.W  #1,(A1)
       MOVEQ   #$08,D0
       BSR     L04196
       MOVE.L  $0058(A0),-(A1)
       MOVE.W  $0056(A0),-(A1)
       RTS

L020EE 
*operation table for coordinates
       DC.L     $121016FA
       DC.L     $0EFB16F4
       DC.L     $0EF516EE
       DC.L     $0EEFE80E
       DC.W     $E900
       
L02100 MOVEM.L D1-D7/A0/A2/A4-A6,-(A7)
       DC.L    $4E56FFC6     * SHOULD BE: LINK A6,$FFC6 WHAT ASM REFUSED
       LEA     $001E(A1),A4
       MOVE.W  (A3)+,D1
L0210E PEA     $0002(A3)
       ADDA.W  (A3),A3
       BSR     L0419E
       MOVEA.L (A7)+,A3
       PEA     $0002(A3)
       ADDA.W  (A3),A3
       JSR     (A3)
       MOVEA.L (A7)+,A3
       DBF     D1,L0210E
       UNLK    A6
       MOVEM.L (A7)+,D1-D7/A0/A2/A4-A6
       MOVEM.L (A7)+,A3/A5
       MOVEQ   #$00,D0
       RTS
       
L02136
XL02136 EQU L02136
       MOVEM.L D0-D1/A3,-(A7)
       TST.L   D2
       BEQ     L021C4
       MOVE.L  D2,-$0010(A6)
       MOVEQ   #-$01,D3
       BTST    #$03,$00028034
       BEQ.S   L02158
       ADD.L   D2,D2
       LSL.L   #1,D3
       ADDQ.W  #1,-$0030(A4)
L02158 MOVE.W  D3,-$0022(A6)
       NEG.L   D2
       MOVE.L  D2,-$0004(A6)
       MOVE.L  D2,-$000C(A6)
       CLR.L   -$0008(A6)
       BSR     L020D8
       MOVEQ   #$10,D0
       BSR     L04196
       BSR.S   L021DC
       LEA     L02218(PC),A3
       BSR     L0419E
       BSR.S   L021CA
       MOVE.L  D1,D2
       BSR.S   L021CA
       MOVE.L  D1,D3
       BSR.S   L021CA
       MOVE.L  D1,D4
       BSR.S   L021CA
       MOVE.L  D1,D6
       BSR.S   L021CA
       MOVE.L  D1,D7
       LEA     -$0060(A4),A1
       BSR.S   L021D6
       MOVEA.W (A1)+,A5
       LEA     -$0018(A4),A1
       BSR.S   L021D2
       MOVE.L  (A1)+,-$0018(A6)
       BSR.S   L021D2
       MOVE.L  (A1)+,D1
       AND.W   -$0022(A6),D1
       MOVE.L  D1,-$0014(A6)
       BSR.S   L021D2
       MOVE.L  (A1)+,D1
       BSR.S   L021D2
       MOVE.L  (A1)+,D0
       AND.W   -$0022(A6),D0
       BSR     L02252
       BSR     L022CA
L021C4 MOVEM.L (A7)+,D0-D1/A3
       RTS

L021CA ADDQ.W  #4,(A1)
       BSR.S   L021D2
       MOVE.L  (A1)+,D1
       RTS

L021D2 MOVEQ   #$06,D0
       BRA.S   L021D8


L021D6 MOVEQ   #$02,D0
L021D8 JMP     L04196(PC)


L021DC MOVE.L  $0052(A0),-(A1)
       MOVE.L  $004E(A0),-(A1)
       MOVE.L  $004A(A0),-(A1)
       RTS

*table to calculate convex. of arc & ellipse
L021EA
XL021EA EQU L021EA
       DC.W    $949A
       DC.W    $0C82
       DC.W    $0E8E
       DC.W    $0E8E
       DC.W    $160E
       DC.W    $169A
       DC.W    $0E82
       DC.W    $160E
       DC.W    $169A
       DC.W    $0E70
       DC.W    $940E
       DC.W    $0A71
       DC.W    $940E
       DC.W    $0A16
       DC.W    $7C0E
       DC.W    $7688
       DC.W    $0E0A
       DC.W    $1470
       DC.W    $880E
       DC.W    $767C
       DC.W    $0E0A
       DC.W    $837D
       DC.W    $0000
L02218 DC.W    $640E
       DC.W    $1416
       DC.W    $F40A
       DC.W    $F5E8
       DC.W    $0AE9
       DC.W    $0E14
       DC.W    $16FA
       DC.W    $0AAC
       DC.W    $0EFB
       DC.W    $EE0A
       DC.W    $AC0E
       DC.W    $EFD0
       DC.W    $AC10
       DC.W    $1676
       DC.W    $0E77
       DC.W    $1682
       DC.W    $0E83
       DC.W    $160E
       DC.W    $700E
       DC.W    $7100
L02240 DC.W    $0801
L02242 DC.W    $56B8
       DC.L    $51EC07f7
       DC.L    $4189374C
L0224C DC.W    $0802
L0224E DC.L    $6487ED51
       
L02252 CMPA.L  #-1,A5
       BEQ.S   L02264
       TST.L   D2
       BEQ.S   L022C0
       TST.L   D3
       BEQ.S   L022C0
       BRA.S   L02266

L02264 SUBA.L  A5,A5
L02266 MOVEA.L D3,A1
       MOVEA.L D4,A2
       ADDA.L  A1,A2
       MOVEA.L D2,A3
       ADDA.L  D4,A3
       ADDA.L  A2,A3
       ADD.L   D4,D3
       NEG.L   D3
       ASR.L   #1,D3
       ADD.L   D7,D3
       MOVE.L  D6,D4
       SUB.L   D3,D4
       ASR.L   #2,D2
       NEG.L   D2
       SUB.L   D6,D2
       ASR.L   #1,D2
       ADD.L   D3,D2
       MOVE.L  A5,-(A7)
       MOVE.L  D2,-(A7)
       MOVE.L  D3,D7
       MOVE.L  D4,D6
       JSR     L02432(PC)
       MOVEA.L (A7)+,A0
       MOVEA.W #$0008,A4
       MOVE.B  #$FF,-$0024(A6)

L022A0 TST.L   D7
       BLT.S   L022A8
       TST.L   D6
       BGE.S   L022C6
L022A8 TST.B   -$0024(A6)
       BGE.S   L022B4
       BSR     L0238A
       BRA.S   L022B8

L022B4 BSR     L023D0
L022B8 CMPA.W  #$0000,A4
       BGT.S   L022A0
       ADDQ.L  #4,A7
L022C0 ADDQ.L  #4,A7
       JMP     L021C4(PC)

L022C6 MOVEA.L (A7)+,A4
       RTS

L022CA BSR     L0248A
       BSR.S   L02330
       MOVE.L  A0,D4
       BGE.S   L022E4
       MOVE.L  -$0004(A6),D4
       MOVE.L  -$0008(A6),D5
       SUB.L   A1,D7
       ADD.L   A2,D6
       ADDA.L  D7,A0
       BRA.S   L022F2


L022E4 MOVE.L  -$000C(A6),D4
       MOVE.L  -$0010(A6),D5
       SUB.L   A2,D7
       ADD.L   A3,D6
       SUBA.L  D6,A0
L022F2 ADD.L   D4,D0
       ADD.L   D5,D1
       TST.L   D5
       BGE.S   L02302
       ADDA.L  #$80,A5
       BRA.S   L0230A


L02302 BEQ.S   L0230C
       SUBA.L  #$80,A5
L0230A SWAP    D3
L0230C MOVEQ   #$01,D5
       BTST    #$03,$00028034
       BEQ.S   L0231A
       MOVEQ   #$02,D5
L0231A TST.L   D4
       BGE.S   L02326
       ROL.W   D5,D2
       BCC.S   L0232E
       SUBQ.L  #2,A5
       BRA.S   L0232E


L02326 BEQ.S   L0232E
       ROR.W   D5,D2
       BCC.S   L0232E
       ADDQ.L  #2,A5
L0232E BRA.S   L022CA


L02330 MOVE.W  A4,D4
       BLT.S   L02386
       SUBQ.W  #2,D4
       BGT.S   L02360
       MOVE.L  D1,D4
       SUB.L   -$0018(A6),D4
       BGE.S   L02342
       NEG.L   D4
L02342 SUBQ.L  #1,D4
       BGT.S   L02360
       MOVE.L  D0,D4
       SUB.L   -$0014(A6),D4
       BGE.S   L02350
       NEG.L   D4
L02350 BTST    #$03,$00028034

       BEQ.S   L0235C
       SUBQ.L  #1,D4
L0235C SUBQ.L  #1,D4
       BLE.S   L02386
L02360 TST.L   D7
       BNE.S   L02368
       TST.L   D6
       BEQ.S   L02386
L02368 BGE.S   L02376
       TST.B   -$0024(A6)
       BGT.S   L02376
       BSR     L0238A
       BRA.S   L02330


L02376 TST.L   D6
       BGE.S   L02388
       TST.B   -$0024(A6)
       BLT.S   L02388
       BSR     L023D0
       BRA.S   L02330


L02386 ADDQ.L  #4,A7
L02388 RTS

L0238A TST.L   -$0004(A6)
       BNE.S   L02394
       NEG.L   -$000C(A6)
L02394 TST.L   -$0008(A6)
       BNE.S   L0239E
       NEG.L   -$0010(A6)
L0239E MOVE.L  A1,D4
       NEG.L   D4
       MOVEA.L D4,A1
       ADD.L   A2,D4
       MOVEA.L D4,A2
       ADDA.L  A1,A2
       MOVE.L  D4,D5
       LSL.L   #2,D5
       SUB.L   A3,D5
       MOVEA.L D5,A3
       NEG.L   D7
       SUB.L   D4,D7
       MOVE.L  A0,D5
       NEG.L   D5
       SUB.L   D6,D5
       ADD.L   D7,D5
       MOVEA.L D5,A0
       SUB.L   D7,D6
       SUB.L   D7,D6
       SUB.L   D4,D6
       SUBQ.L  #1,A4
       MOVE.B  #$01,-$0024(A6)

       RTS

L023D0 TST.L   -$0008(A6)
       BNE.S   L023E2
       CLR.L   -$0004(A6)
       MOVE.L  -$0010(A6),-$0008(A6)

       BRA.S   L023F2


L023E2 TST.L   -$0004(A6)
       BNE.S   L023F2
       CLR.L   -$0008(A6)
       MOVE.L  -$000C(A6),-$0004(A6)

L023F2 MOVE.L  A2,D4
       LSL.L   #1,D4
       SUB.L   A3,D4
       MOVE.L  D4,D5
       SUB.L   A1,D5
       MOVEA.L D5,A1
       SUBA.L  A3,A2
       MOVE.L  A3,D5
       NEG.L   D5
       MOVEA.L D5,A3
       MOVE.L  A2,D5
       ASR.L   #1,D5
       NEG.L   D5
       ADD.L   D6,D5
       ADD.L   D5,D7
       MOVE.L  D6,D5
       ASR.L   #1,D5
       NEG.L   D5
       SUB.L   A0,D5
       ADD.L   D7,D5
       MOVEA.L D5,A0
       MOVE.L  A3,D5
       ASR.L   #3,D5
       ADDA.L  D5,A0
       NEG.L   D6
       ASR.L   #1,D4
       ADD.L   D4,D6
       SUBQ.L  #1,A4
       MOVE.B  #$FF,-$0024(A6)

       RTS

L02432 MOVEM.L D0-D1,-(A7)
       CLR.L   D2
       NEG.L   D1
       SUBQ.L  #1,D1
       MOVE.W  $001E(A0),D2
       ADD.W   $001A(A0),D2
       ADD.L   D2,D1
       MOVE.W  $0018(A0),D2
       ADD.L   D2,D0
       MOVE.L  $003E(A0),D3
       BTST    #$00,D1
       BEQ.S   L02458
       SWAP    D3
L02458 MOVEA.L #$00020000,A5

       LSL.L   #7,D1
       ADDA.L  D1,A5
       MOVE.L  D0,D1
       LSR.L   #3,D1
       LSL.L   #1,D1
       ADDA.L  D1,A5
       ANDI.W  #$000F,D0
       MOVEQ   #$00,D2
       MOVE.W  #$8080,D2
       BTST    #$03,$00028034

       BEQ.S   L02482
       MOVE.W  #$C0C0,D2
L02482 ROR.W   D0,D2
       MOVEM.L (A7)+,D0-D1
       RTS

L0248A CMP.L   -$0020(A6),D1
       BCC     L02546
       TST.B   -$0032(A6)
       BEQ     L0251C
       MOVEM.L D0-D3/A0-A1,-(A7)
       MOVEA.L D1,A0
       ADDA.L  A0,A0
       ADDA.L  A0,A0
       ADDA.L  #$00000010,A0
       ADDA.L  -$002A(A6),A0
       MOVE.L  (A0),D2
       BSET    #$1F,D0
       MOVE.L  D0,(A0)
       LSL.L   #1,D0
       ASR.L   #1,D0
       LSL.L   #1,D2
       BCC.S   L02516
       ASR.L   #1,D2
       MOVE.L  D2,D4
       SUB.L   D0,D4
       BGE.S   L024C8
       EXG     D0,D2
L024C8 TST.L   D0
       BGE.S   L024CE
       MOVEQ   #$00,D0
L024CE TST.L   D2
       BLT.S   L02516
       CMP.L   -$001C(A6),D0
       BGE.S   L02516
       CMP.L   -$001C(A6),D2
       BLT.S   L024E2
       MOVE.L  -$001C(A6),D2
L024E2 SUB.L   D0,D2
       ADD.L   -$0036(A6),D0
       NEG.L   D1
       ADD.L   -$003A(A6),D1
       ADD.L   -$0020(A6),D1
       SUBQ.L  #1,D1
       MOVE.W  D3,-(A7)
       MOVE.W  D3,-(A7)
       SWAP    D3
       MOVE.W  D3,-(A7)
       MOVE.W  D3,-(A7)
       MOVEA.L A7,A1
       MOVEQ   #$01,D3
       BTST    #$03,-$0023(A6)
       BNE.S   L02510
       JSR     L025BE(PC)
       BRA.S   L02514


L02510 JSR     L025CA(PC)
L02514 ADDQ.L  #8,A7
L02516 MOVEM.L (A7)+,D0-D3/A0-A1
       RTS

L0251C CMP.L   -$001C(A6),D0
       BCC.S   L02546
       SWAP    D2
       SWAP    D3
       MOVE.L  D3,D4
       AND.L   D2,D4
       BTST    #$03,-$0023(A6)

       BNE.S   L02540
       MOVE.L  (A5),D5
       NOT.L   D2
       AND.L   D2,D5
       NOT.L   D2
       OR.L    D4,D5
       MOVE.L  D5,(A5)
       BRA.S   L02542


L02540 EOR.L   D4,(A5)
L02542 SWAP    D2
       SWAP    D3
L02546 RTS

L02548 MOVEM.L D0-D7/A0-A6,-(A7)
       BSR.S   L0256A
       MOVE.L  #$00FF00FF,D6
       MOVE.L  D6,D7
       BRA.S   L025D0


L02558 MOVE.L  (A1),D6
       MOVE.W  D6,D7
       SWAP    D7
       MOVE.W  D6,D7
       MOVE.W  (A1),D6
       BTST    #$00,D1
       BNE.S   L0256A
       EXG     D6,D7
L0256A LSL.W   #7,D1
       MOVEA.L #$00020000,A1        * screen mem address
       ADDA.W  D1,A1
       LSL.W   #6,D3
       MOVEA.W D3,A2
       ADDA.L  A2,A2
       MOVE.W  D0,D1
       LSR.W   #4,D1
       LSL.W   #2,D1
       ADDA.W  D1,A1
       ADDA.L  A1,A2
       MOVEA.W #$0080,A3
       LSR.W   #2,D1
       ADD.W   D0,D2
       MOVE.W  D2,D3
       SUBQ.W  #1,D3
       ASR.W   #4,D3
       SUB.W   D1,D3
       MOVEA.W D3,A5
       ADDA.W  A5,A5
       ADDA.W  A5,A5
       BSR.S   L025AA
       MOVE.L  D5,D4
       MOVE.W  D2,D0
       BSR.S   L025AA
       NOT.L   D5
       BNE.S   L025A8
       MOVEQ   #-$01,D5
L025A8 RTS

L025AA MOVEQ   #-$01,D5
       ANDI.W  #$000F,D0
       LSR.W   D0,D5
       MOVE.W  D5,D0
       LSL.L   #8,D5
       MOVE.W  D0,D5
       LSL.L   #8,D5
       MOVE.B  D0,D5
       RTS

L025BE MOVEM.L D0-D7/A0-A6,-(A7)
       BSR.S   L02558
L025C4 LEA     L026EC(PC),A6
       BRA.S   L025F4


L025CA MOVEM.L D0-D7/A0-A6,-(A7)
       BSR.S   L02558
L025D0 LEA     L026F4(PC),A6
       BRA.S   L025F4


L025D6 MOVEM.L D0-D7/A0-A6,-(A7)
       MOVEA.L A1,A4
       BSR.S   L0256A
       ADD.W   D3,D3
       ADDQ.W  #1,D3
       BTST    #$03,$0034(A6)  * SV.MCSTA
       BNE.S   L025F0
       LEA     L0273E(PC),A6
       BRA.S   L025F4


L025F0 LEA     L02708(PC),A6
L025F4 BSR     L026E6
       MOVEM.L (A7)+,D0-D7/A0-A6
       RTS

L025FE MOVEM.L D0-D7/A0-A6,-(A7)
       BSR     L02558
       MOVE.W  $0012(A7),D2
       NEG.W   D2
       LSL.W   #7,D2
       BVS.S   L025C4
       BGT.S   L02630
       EXG     A1,A2
       MOVEA.W #$FF80,A3
       ADDA.L  A3,A1
       ADDA.L  A3,A2
       MOVE.W  A1,D0
       SUB.W   A2,D0
       TST.B   D0
       BNE.S   L02626
       EXG     D6,D7
L02626 LEA     $00(A1,D2.W),A4
       CMPA.L  A2,A4
       BLS.S   L025C4
       BRA.S   L02638


L02630 LEA     $00(A1,D2.W),A4
       CMPA.L  A4,A2
       BLS.S   L025C4
L02638 LEA     L026FC(PC),A6
       SUBA.W  D2,A2
       BSR     L026E6
       ADDA.W  D2,A2
       BRA     L025C4


L02648 MOVEM.L D0-D7/A0-A6,-(A7)
       BSR     L02558
       SWAP    D3
       MOVE.W  $0012(A7),D2
       NEG.W   D2
       BGT.S   L0268A
       NEG.W   D2
       MOVE.W  D2,D3
       ANDI.W  #$000F,D3
       ADDI.W  #$0010,D3
       SWAP    D3
       LSR.W   #4,D2
       CMP.W   D3,D2
       BHI     L025C4
       SUB.W   D2,D3
       MOVEA.W #$FFFC,A0
       ADDA.W  A5,A1
       ADDA.W  A5,A2
       MOVEA.L A1,A4
       LSL.W   #2,D2
       SUBA.W  D2,A4
       MOVE.L  A5,D2
       NEG.L   D2
       MOVEA.L D2,A5
       EXG     D4,D5
       BRA.S   L026AC


L0268A MOVEA.W #$0004,A0
       MOVE.W  D2,D3
       ANDI.W  #$000F,D3
       NEG.W   D3
       ADDI.W  #$0010,D3
       SWAP    D3
       LSR.W   #4,D2
       CMP.W   D3,D2
       BHI     L025C4
       SUB.W   D2,D3
       LSL.W   #2,D2
       LEA     $00(A1,D2.W),A4
L026AC ADDQ.W  #1,D3
       LEA     L02770(PC),A6
       BRA     L025F4


L026B6 MOVE.W  D3,D0
       BMI.S   L026EA
       EXG     D6,D7
       MOVE.L  (A1),-(A7)
       MOVE.L  $00(A1,A5.W),-(A7)
       JMP     (A6)


L026C4 SUBQ.W  #4,A1
L026C6 MOVE.L  (A1),D0
       AND.L   D5,D0
       MOVE.L  D5,D1
       NOT.L   D1
       AND.L   (A7)+,D1
       OR.L    D1,D0
       MOVE.L  D0,(A1)
       SUBA.L  A5,A1
       MOVE.L  (A1),D0
       AND.L   D4,D0
       MOVE.L  D4,D1
       NOT.L   D1
       AND.L   (A7)+,D1
       OR.L    D1,D0
       MOVE.L  D0,(A1)
       ADDA.L  A3,A1
L026E6 CMPA.L  A2,A1
       BNE.S   L026B6
L026EA RTS

L026EC MOVE.L  D6,(A1)+
       DBF     D0,L026EC
       BRA.S   L026C4

L026F4 EOR.L   D6,(A1)+
       DBF     D0,L026F4
       BRA.S   L026C4

L026FC LEA     $00(A1,D2.W),A4
L02700 MOVE.L  (A4)+,(A1)+
       DBF     D0,L02700
       BRA.S   L026C4

L02708 MOVE.B  (A1),D6
       MOVE.B  $0001(A1),D7
       MOVEQ   #$03,D1
L02710 MOVEQ   #$00,D2
       MOVE.B  D6,D2
       LSL.B   #6,D2
       LSL.W   #1,D2
       MOVE.B  D7,D2
       LSL.B   #6,D2
       LSR.W   #6,D2
       MOVE.B  $00(A4,D2.W),D2
       ROXR.B  #1,D2
       ROXR.B  #1,D7
       ROXR.B  #1,D2
       ROXR.B  #1,D7
       ROR.B   #1,D6
       ROXR.B  #1,D2
       ROXR.B  #1,D6
       DBF     D1,L02710
       MOVE.B  D6,(A1)+
       MOVE.B  D7,(A1)+
       DBF     D0,L02708
       BRA.S   L026C4


L0273E MOVE.B  (A1),D6
       MOVE.B  $0001(A1),D7
       MOVEQ   #$07,D1
L02746 MOVEQ   #$00,D2
       MOVE.B  D6,D2
       LSL.B   #7,D2
       LSL.W   #1,D2
       MOVE.B  D7,D2
       LSL.B   #7,D2
       LSR.W   #6,D2
       MOVE.B  $00(A4,D2.W),D2
       ROXR.B  #2,D2
       ROXR.B  #1,D7
       ROXR.B  #1,D2
       ROXR.B  #1,D6
       DBF     D1,L02746
       MOVE.B  D6,(A1)+
       MOVE.B  D7,(A1)+
       DBF     D0,L0273E
       BRA     L026C4


L02770 MOVE.W  A5,-(A7)
       MOVE.L  A4,-(A7)
       MOVE.L  D6,-(A7)
       ADDA.L  A1,A5
       MOVE.L  (A5),D2
       AND.L   D5,D2
       MOVE.L  D5,D1
       NOT.L   D1
       AND.L   D6,D1
       OR.L    D1,D2
       MOVE.L  D2,(A5)
       ADDA.L  A0,A5
       SWAP    D3
       MOVEP.W $0000(A4),D1
       MOVEP.W $0001(A4),D2
       BRA.S   L027B4


L02794 ADDA.L  A0,A4
L02796 SWAP    D1
       SWAP    D2
       MOVEP.W $0000(A4),D1
       MOVEP.W $0001(A4),D2
       MOVE.L  D1,D6
       ROR.L   D3,D6
       MOVEP.W D6,$0000(A1)
       MOVE.L  D2,D6
       ROR.L   D3,D6
       MOVEP.W D6,$0001(A1)
       ADDA.L  A0,A1
L027B4 SUBQ.W  #1,D0
       BGT.S   L02794
       BLT.S   L027BE
       MOVEA.L A7,A4
       BRA.S   L02796


L027BE MOVE.L  (A7)+,D6
       MOVEA.L (A7)+,A4
       SWAP    D3
       BRA.S   L027CA


L027C6 MOVE.L  D6,(A1)
       ADDA.L  A0,A1
L027CA CMPA.L  A1,A5
       BNE.S   L027C6
       MOVEA.W (A7)+,A5
       ADDA.L  A3,A4
       SUBA.L  A0,A1
       BRA     L026C6


L027D8 MOVEM.L D1-D2,-(A7)
       BSR.S   L0281E
       MOVE.W  D2,(A1)
       MOVE.W  D2,$0002(A1)
       LSR.B   #3,D1
       BEQ.S   L02818
       BSR.S   L0281E
       LSR.B   #3,D1
       BTST    #$00,D1
       BEQ.S   L027F6
       EOR.W   D2,$0002(A1)
L027F6 CMPI.B  #$01,D1
       BEQ.S   L02818
       BTST    #$03,$0034(A6)  * SV.MCSTA

       BEQ.S   L0280A
       ANDI.W  #$3333,D2
       BRA.S   L0280E


L0280A ANDI.W  #$5555,D2
L0280E EOR.W   D2,(A1)
       TST.B   D1
       BEQ.S   L02818
       EOR.W   D2,$0002(A1)
L02818 MOVEM.L (A7)+,D1-D2
       RTS

L0281E MOVE.B  D1,D2
       ANDI.W  #$0007,D2
       ROR.L   #2,D2
       LSL.W   #7,D2
       ROL.L   #2,D2
       BTST    #$03,$0034(A6)  * SV.MCSTA
       BEQ.S   L02838
       MULU    #$0055,D2
       BRA.S   L0283E


L02838 LSR.W   #1,D2
       MULU    #$00FF,D2
L0283E RTS

* ROUTINE TO PRINT CHAR ON SCR
* CALLED BY TRAP#3,D0=5

L02840 MOVEM.L D0-D7/A0-A6,-(A7)
       MOVEM.L (A1),D6-D7 * D7=ink mask
       BTST    #$00,D1    * odd adress
       BNE.S   L02852
       SWAP    D6         * invert masque
       SWAP    D7         *
L02852 ANDI.W  #$00FF,D2  * character to print
       MOVEA.L A2,A4      * pointer to first charfont
       SUB.B   (A4)+,D2   * higher?
       CMP.B   (A4)+,D2
       BLS.S   L0286A     * No
       ADD.B   (A2),D2
       MOVEA.L A3,A4      * second char font
       SUB.B   (A4)+,D2
       CMP.B   (A4)+,D2
       BLS.S   L0286A     * ok
       MOVEQ   #$00,D2    * char not printable
L0286A ADDA.W  D2,A4      * get value in charlist
       LSL.W   #3,D2
       ADDA.W  D2,A4
       MOVEA.L #$00020000,A1
       LSL.W   #7,D1
       ADDA.W  D1,A1
       MOVE.W  D0,D1
       LSR.W   #3,D0
       ADD.W   D0,D0
       ADDA.W  D0,A1
       ANDI.W  #$0007,D1
       MOVEA.W #-1,A5
       BTST    #$00,D3  * mode underline ?
       BEQ.S   L02892   * no
       ADDQ.W  #2,A5
L02892 MOVEQ   #$00,D0
       MOVEQ   #$7E,D2
       ADD.W   D2,D2    * D2 = $FC
       MOVEQ   #$00,D5
       BTST    #$06,D3  * mode 8
       BEQ.S   L028B4
       MOVEQ   #-$01,D0
       MOVE.W  #$FFF0,D2
       ADDQ.W  #8,D1
       BTST    #$01,D3  * mode flash?
       BEQ.S   L028B4
       MOVE.W  #$4010,D5
       ROR.L   D1,D5
L028B4 BTST    #$05,D3  * mode extended width
       BEQ.S   L028BC
       ASR.B   #4,D2
L028BC MOVEQ   #$00,D4
       BTST    #$04,D3  * mode double height
       BEQ.S   L028C6
       MOVEQ   #-$01,D4
L028C6 ROR.L   D1,D2
       LEA     L02924(PC),A6  * adress for printing
       BTST    #$02,D3    * mode transparent background
       BEQ.S   L028E0
       LEA     L0293A(PC),A6  * adress for printing
       BTST    #$03,D3    * XOR characters/graphics
       BEQ.S   L028E0
       LEA     L02936(PC),A6  * adress for printing
L028E0 MOVEA.L A1,A2      * adress on screen
       MOVE.B  D2,D0      * copy byte to print in long word
       LSL.W   #8,D2
       MOVE.B  D0,D2
       LSL.W   #8,D5
       MOVE.W  #$0009,D0 * loop counter
       MOVEQ   #$00,D3
       BRA.S   L0291C    * adress to add masque
 

L028F2 MOVEQ   #$00,D3   * loop for printing
       CMP.W   A5,D0     * underline?
       BNE.S   L028FE
       MOVEQ   #-$01,D3
       ADDQ.W  #1,A4
       BRA.S   L02914


L028FE MOVE.B  (A4)+,D3  * char-matrix in d3
       BEQ.S   L0291C
       TST.L   D0        * 6 or 8 pixels size
       BGE.S   L0290C
       LSR.B   #1,D3
       MOVE.W  L0297C(PC,D3.W),D3    * convert-table 6*9 to 12 * 9
L0290C ROR.W   D1,D3     * calculate any pixel depending on size
       MOVE.B  D3,D4     * and char-matrix
       LSL.W   #8,D3
       MOVE.B  D4,D3
L02914 AND.W   D2,D3
       MOVE.W  D3,D4
       SWAP    D3
       MOVE.W  D4,D3
L0291C MOVE.W  D3,D4
       AND.W   D7,D4
       OR.W    D5,D4
       JMP     (A6)

L02924 EOR.W   D2,D3
       AND.W   D6,D3
       OR.W    D4,D3
       MOVE.W  D2,D4
       NOT.W   D4
       AND.W   (A1),D4
       OR.W    D3,D4    * at last - value to print
       MOVE.W  D4,(A1)  * on screen
       BRA.S   L02942   * continue

L02936 EOR.W   D4,(A1)
       BRA.S   L02942

L0293A NOT.W   D3
       AND.W   (A1),D3
       OR.W    D4,D3
       MOVE.W  D3,(A1)
L02942 SWAP    D6
       SWAP    D7
       ADDA.W  #$0080,A1
       TST.L   D4       * normal size
       BGE.S   L02956   * yes
       SWAP    D3
       BCHG    #$1E,D4
       BNE.S   L0291C
L02956 DBF     D0,L028F2
       CLR.W   D2
       ROL.L   #8,D2
       BEQ.S   L02976   * character written ½ end
       CLR.W   D5
       ROL.L   #8,D5
       SUBQ.B  #8,D1
       ANDI.B  #$0F,D1
       MOVEA.L A2,A1
       ADDQ.W  #2,A1
       SUBA.W  #$0009,A4
       BRA     L028E0   * second run

L02976 MOVEM.L (A7)+,D0-D7/A0-A6
       RTS

*
*       sreen-pixel translate code 
*       transfers 6*9 matrix to 12 * 9 matrix
*

L0297C DC.W    $0000
       DC.W    $0030
       DC.W    $00C0
       DC.W    $00F0
       DC.W    $0300
       DC.W    $0330
       DC.W    $03C0
       DC.W    $03F0
       DC.W    $0C00
       DC.W    $0C30
       DC.W    $0CC0
       DC.W    $0CF0
       DC.W    $0F00
       DC.W    $0F30
       DC.W    $0FC0
       DC.W    $0FF0
       DC.W    $3000
       DC.W    $3030
       DC.W    $30C0
       DC.W    $30F0
       DC.W    $3300
       DC.W    $3330
       DC.W    $33C0
       DC.W    $33F0
       DC.W    $3C00
       DC.W    $3C30
       DC.W    $3CC0
       DC.W    $3CF0
       DC.W    $3F00
       DC.W    $3F30
       DC.W    $3FC0
       DC.W    $3FF0
       DC.W    $C000
       DC.W    $C030
       DC.W    $C0C0
       DC.W    $C0F0
       DC.W    $C300
       DC.W    $C330
       DC.W    $C3C0
       DC.W    $C3F0
       DC.W    $CC00
       DC.W    $CC30
       DC.W    $CCC0
       DC.W    $CCF0
       DC.W    $CF00
       DC.W    $CF30
       DC.W    $CFC0
       DC.W    $CFF0
       DC.W    $F000
       DC.W    $F030
       DC.W    $F0C0
       DC.W    $F0F0
       DC.W    $F300
       DC.W    $F330
       DC.W    $F3C0
       DC.W    $F3F0
       DC.W    $FC00
       DC.W    $FC30
       DC.W    $FCC0
       DC.W    $FCF0
       DC.W    $FF00
       DC.W    $FF30
       DC.W    $FFC0
       DC.W    $FFF0

     include flp1_mdv_sys

* execution of command to 8049
L02C72 MOVE    SR,-(A7)    * transmission with 8049 rts=rte
       ORI.W   #$0700,SR   * disable interrupts
       JSR     L02F6E(PC)  * returns D6=6  A0=$18020  A1=$18003
       MOVE.B  (A3)+,D0    * d0 = command-type
       BSR.S   L02CC8      * do it
       MOVE.B  (A3)+,D7    * number of params
       MOVE.L  (A3)+,D4    * sort of params
L02C84 SUBQ.B  #1,D7       * no params
       BLT.S   L02CA4      * go on
       MOVE.B  (A3)+,D0
       BTST    #$00,D4
       BNE.S   L02CA0
       BTST    #$01,D4
       BEQ.S   L02C9E
       MOVE.W  D0,D5
       ROR.W   #4,D0
       BSR.S   L02CC8
       MOVE.W  D5,D0
L02C9E BSR.S   L02CC8
L02CA0 ROR.L   #2,D4
       BRA.S   L02C84


L02CA4 MOVE.B  (A3)+,D4
       BTST    #$00,D4
       BNE.S   L02CBC
       BTST    #$01,D4
       BNE.S   L02CB8
       JSR     L02F96(PC)
       BRA.S   L02CBC


L02CB8 JSR     L02F9A(PC)   * the answer of 8049
L02CBC MOVEQ   #$02,D7
       OR.B    $0035(A6),D7 * SV.PCINT
       MOVE.B  D7,$0001(A0)
       RTE


L02CC8 JMP     L02F7C(PC)     * command for 8079


L02CCC MOVEM.L D0-D6/A0-A4,-(A7)    * interrupt 2 - interface
       MOVEQ   #$00,D3
       BSR.S   L02D20
       MOVEQ   #$02,D7
       BRA.S   L02CE6

L02CD8 MOVEM.L D0-D6/A0-A4,-(A7)    * interrupt 2 - transmission
       MOVEQ   #$00,D3
       ST      D4
       BSR     L02D74
       MOVEQ   #$04,D7
L02CE6 OR.B    $0035(A6),D7  * SV.PCINT
       MOVE.B  D7,$00018021
       MOVEM.L (A7)+,D0-D6/A0-A4
       BRA     L003B6

* table of interrupt tasks
L02CF8 
       DC.L    0        * no following table
       DC.L    L02D08   * interrupt-routines
       
* table of scheduler tasks
L02D00 DC.L    L03480   * List of next linkage
       DC.L    L02D14   * adress of scheduler task

L02D08 MOVE    SR,-(A7)    * RTS=RTE !
       ORI.W   #$0700,SR
       BSR.S   L02D20      * ask 8049
       JMP     L02CBC(PC)  * end


L02D14 MOVE    SR,-(A7)   * serial I/O
       ORI.W   #$0700,SR
       SF      D4         * D4.B = 0
       BSR.S   L02D74
       RTE

L02D20 JSR     L02F6E(PC)    * returns D6=6  A0=$18020  A1=$18003
       MOVEQ   #$01,D0       * command 1 to 8049 = respond
       JSR     L02F7C(PC)    * command for 8079
       JSR     L02F9A(PC)    * receive demands
       MOVE.B  D1,D7         * d7: received byte
       BTST    #$06,D7       * bit 6=0? mdv write not allowed
       SEQ     $0094(A6)     * SV.WP
       BTST    #$01,D7       * bit 1=1 beeper activ
       SNE     $0096(A6)     * SV.SOUND
       BTST    #$00,D7       * bit 0=0 keyboard-buff empty
       BEQ.S   L02D4A
       JSR     L02E58(PC)      * transfer keyboard buff
L02D4A MOVE.L  $0098(A6),D0    * no ser# open
       BEQ.S   L02D5E
       BTST    #$04,D7    * bit 4 = 0 ser# did nothing receive
       BEQ.S   L02D5E
       MOVEA.L D0,A2
       MOVEQ   #$06,D5
       JSR     L02E18(PC)       * receive
L02D5E MOVE.L  $009C(A6),D0     * now same proc with ser2
       BEQ.S   L02D72
       BTST    #$05,D7
       BEQ.S   L02D72
       MOVEA.L D0,A2
       MOVEQ   #$07,D5
       JSR     L02E18(PC)
L02D72 RTS

L02D74 LEA     $00A0(A6),A4  * prepare for ser# - receiving SV.TMODE
       BTST    #$04,(A4)
       BNE.S   L02D88
       LEA     $00018020,A1
       BTST    #$01,(A1)
L02D88 BNE.S   L02E02
       MOVEQ   #$00,D6    * d6=0 : ser1
       MOVE.B  (A4),D6    * d6=1 : ser2
       LSL.B   #4,D6
       LSR.B   #7,D6
       MOVE.W  D6,D7
       ADDQ.B  #4,D7
       LSL.B   #2,D6
       LEA     $0098(A6),A5  *SV.SER1C
       ADDA.W  D6,A5
       MOVE.L  (A5),D0
       BEQ.S   L02E04
       MOVEA.W #$0062,A2    * a2= start addr. of out-file
       ADDA.L  D0,A2
       TST.B   -$0065(A2)
       BEQ.S   L02DB2
       BTST    D7,(A1)
       BNE.S   L02DBE
L02DB2 JSR     L0385E(PC)   * IO.QOUT
       BEQ.S   L02DF6       * correct received
       ADDQ.L  #1,D0
       BEQ.S   L02E04
       BRA.S   L02DD4

L02DBE JSR     L0380A(PC)  * IO.QTEST
       CMPI.W  #$FFF6,D0
       BNE.S   L02E04
       TST.B   -$0063(A2)
       BLT.S   L02DD4
       TST.B   -$0065(A2)
       BNE.S   L02E02
L02DD4 TST.B   D4
       BNE.S   L02E02
       MOVE.B  -$0063(A2),D6
       LEA     -$0082(A2),A0
       JSR     L0305E(PC)    * MT.RECHP
       CLR.L   (A5)
       TST.B   D6
       BLT.S   L02E02
       MOVEQ   #$1A,D1
       BTST    #$00,-$0067(A2)    * parity even?
       BEQ.S   L02DF6
       MOVEQ   #-$66,D1
L02DF6 MOVE.B  D1,$00018022
       MOVE.W  $00A8(A6),$00A6(A6)  * SV.TIMOV
L02E02 RTS
        
L02E04 SUB.W   D3,$00A6(A6)    * ser timing SV.TIMOV
       BGE.S   L02E02
       CLR.W   $00A6(A6)
       BCHG    #$03,(A4)
       MOVE.B  (A4),-$001E(A1)
       RTS

L02E18 JSR     L0380A(PC)    * IO.QTEST  receive ser#
       CMPI.W  #$0019,D2
       BLT.S   L02E56
       MOVE.L  D5,D0
       JSR     L02F7C(PC)     * command for 8079 depending on D0
       JSR     L02F9A(PC)
       MOVE.B  D1,D4
       ANDI.W  #$003F,D4
       BEQ.S   L02E56(PC)
       SUBQ.W  #1,D4
L02E36 JSR     L02F9A(PC)
       TST.B   -$0002(A2)
       BLT.S   L02E4E
       MOVEQ   #$7F,D0
       AND.B   D1,D0
       CMPI.B  #$1A,D0
       BNE.S   L02E4E
       JSR     L03888(PC)    * IO.QEOF
L02E4E JSR     L03838(PC)    * IO.QIN
       DBF     D4,L02E36     * continue reading
L02E56 RTS

L02E58 MOVEA.L $004C(A6),A2  * clear 8049 - keyboard buffer
       MOVE.L  A2,D0
       BEQ.S   L02EC0        * = no con open
       MOVEQ   #$08,D0       * command 8=read keyboard
       JSR     L02F7C(PC)    * command for 8079
       JSR     L02F96(PC)    * receive
       MOVE.B  D1,D5         * d1=d5=d4 : number of bytes in buffer
       MOVE.B  D1,D4
       ANDI.W  #$0007,D4
       BEQ.S   L02E96    * if empty - out
       SUBQ.W  #1,D4
L02E76 CLR.W   $008A(A6)    * autorepeat buffer
       JSR     L02F96(PC)    * receive ctrl alt shift
       MOVE.B  D1,D2
       JSR     L02F9A(PC)
       MOVEA.L $BFF2,A3
       JSR     (A3)      * convert to ASCII 
       BRA.S   L02EC4    * ctrl - space
       BRA.S   L02EC2    * no char implemented !!! change to 2ec0 !!!
       BSR.S   L02EEC
       DBF     D4,L02E76 * look for next bytes in buffer
L02E96 BTST    #$03,D5   * if less then 8 chrs in buffer ½ end
       BEQ.S   L02EBA
       SUB.W   D3,$0090(A6)  * SV.ARCNT
       BGT.S   L02EC0
       JSR     L0380A(PC)    * IO.QTEST
       TST.L   D0            * no new entries
       BEQ.S   L02EB2
       MOVE.W  $008A(A6),D1  * SV.ARBUF
       BEQ.S   L02EB2
       BSR.S   L02EEC
L02EB2 MOVE.W  $008E(A6),$0090(A6) * SV.ARFRQ ½ SV.ARCNT
       RTS

L02EBA MOVE.W  $008C(A6),$0090(A6) * restore autorepeat
L02EC0 RTS

* !!! CHANGE ABOVE AND REMOVE - DOUBLE RTS IS NONSENS !!!

L02EC2 RTS

L02EC4 SF      $0033(A6)     * was ctrl-space ? clear SV.SCRST
       MOVEA.L $0068(A6),A3  * SV.JBBAS
       MOVEA.L (A3),A3       * SuperBasic
       SF      $00F7(A3)        * BV.BRK
       MOVE.W  $0014(A3),D0     * job.stat
       BEQ.S   L02EEA           * ok ->
       ADDQ.W  #1,D0
       BLT.S   L02EEA           * waiting for job ->
       CLR.W   $0014(A3)
       MOVE.L  $000C(A3),D0     * release flag
       BEQ.S   L02EEA
       MOVEA.L D0,A3
       SF      (A3)
L02EEA RTS

L02EEC CMPI.W  #$00F9,D1     * ctrl-f5 ?
       BEQ.S   L02F3A        * invert screen status
       SF      $0033(A6)     * SV.SCRST
       CMP.W   $0092(A6),D1  * ctrl-c ? SV.CQCH
       BEQ.S   L02F40
       CMPI.W  #$00E0,D1    * capslock ?
       BNE.S   L02F12
       NOT.B   $0088(A6)    * invert capslock mode SV.CAPS
       TST.L   $00A2(A6)    * if new: acitvate     SV.CSUB
       BEQ.S   L02EC0
       LEA     $00A2(A6),A5
       JMP     (A5)        * will return 

L02F12 MOVE.W  $008C(A6),$0090(A6)    * SV.ARDEL ½ SV.ARFRQ
       MOVE.W  D1,$008A(A6)           * autorepeat - buffer
       CMPI.B  #-1,D1
       BNE.S   L02F36
       SWAP    D1
       JSR     L0380A(PC)    * IO.QTEST
       CMPI.W  #$0002,D2
       BLT.S   L02EC0
       SWAP    D1
       JSR     L03838(PC)    * IO.QIN
       LSR.W   #8,D1
L02F36 JMP     L03838(PC)    * IO.QIN

L02F3A NOT.B   $0033(A6)    * invert screen status
       RTS

L02F40 LEA     -$0068(A2),A0    * a0 = chbase
       TST.B   $0043(A0)
       BGE.S   L02F54           * cursor activ
       JSR     L01B86           * reactivate
       NOP                      * !!! to conform asm !!!
       LEA     $0068(A0),A2     * pointer to Job-base
L02F54 MOVEA.L (A2),A2
       CMPA.L  $004C(A6),A2     * keyboard-queue ok?
       BEQ.S   L02F6A
       TST.B   -$0025(A2)
       BEQ.S   L02F54
       MOVE.L  A2,$004C(A6)     * SV.KEYQ
       CLR.W   $AA(A6)
       
* omit instruction but let label !!!

L02F6A JMP     L02F6E(PC)    * returns D6=6  A0=$18020  A1=$18003

 
* set parameters for transmission to 8049        
L02F6E LEA     $00018003,A1     * A1 = 8049 - write reg
       LEA     $001D(A1),A0     * A0 = status-control 8049
       MOVEQ   #$06,D6
       RTS
* command for 8079  - depends on value in D0
L02F7C LSL.B   #4,D0    * send command to 8049 D0 * 16
       ORI.B   #$08,D0  * bit 3 = 1
L02F82 LSL.B   #1,D0
       BEQ.S   L02F94
       MOVEQ   #$03,D1
       ROXL.B  #1,D1
       ASL.B   #1,D1
       MOVE.B  D1,(A1)
L02F8E BTST    D6,(A0)  * wait till bit 6 ist 0 - ackn of 8049
       BNE.S   L02F8E
       BRA.S   L02F82
L02F94 RTS

L02F96 MOVEQ   #$10,D1  * decrement counter
       BRA.S   L02F9C   * receive

L02F9A MOVEQ   #$01,D1 
L02F9C MOVE.B  #$0E,(A1) * $0E an 8049 : ready to receive
L02FA0 BTST    D6,(A0)
       BNE.S   L02FA0    * wait
       MOVE.B  (A0),D0   * receive bits
       ROXL.B  #1,D0
       ROXL.B  #1,D1
       BCC.S   L02F9C    * till complete
       RTS

* Vector-handling
 
* allocate memory in common heap
        
L02FAE LEA     $0008(A6),A0     * MM.ALCHP
       MOVEQ   #$0F,D2  
       JSR     L03106(PC)       * reserve D1 bytes
       BLT.S   L02FD6
       LEA     $0004(A6),A2     * SV.CHEAP
       CMPA.L  A1,A2
       BEQ.S   L02FC6
       CLR.L   $0008(A1)
L02FC6 MOVE.L  D1,D0
       ADDQ.W  #4,A0
       SUBQ.L  #4,D0
L02FCC CLR.L   (A0)+
       SUBQ.L  #4,D0
       BGT.S   L02FCC
       SUBA.L  D1,A0    * A0 = base of reserved space
       BRA.S   L02FF8

* allocate memory in transient area

L02FD6 MOVE.L  D1,-(A7)
       ADDA.L  (A0),A1
       CMPA.L  $000C(A6),A1  * SV.FREE
       BNE.S   L02FE2
       SUB.L   (A0),D1
L02FE2 JSR     L0324E(PC)
       BNE.S   L02FF6
       SUBA.L  D1,A0
       LEA     $0008(A6),A1  * SV.CHPFR
       JSR     L0315E(PC)
       MOVE.L  (A7)+,D1
       BRA.S   L02FAE     * MM.ALCHP

L02FF6 ADDQ.W  #4,A7
L02FF8 RTS


* reserve in transient prog aera d1 bytes

L02FFA LEA     $0018(A6),A0  * SV.TRNFR
       MOVEQ   #$0F,D2
       MOVEQ   #$01,D0
       JSR     L03134(PC)
       TST.L   D2
       BGT.S   L03032
       MOVE.L  D1,-(A7)
       LEA     $0014(A6),A1  * SV.TRNSP
       ADDA.L  $0004(A1),A1
       CMPA.L  $0014(A6),A1
       BNE.S   L0301C
       SUB.L   (A1),D1
L0301C JSR     L031B8(PC)     * allocate memory
       BNE.S   L0305A
       SUB.L   D1,$0014(A6)
       LEA     $0018(A6),A1  * SV.TRNFR
       JSR     L0315E(PC)
       MOVE.L  (A7)+,D1
       BRA.S   L02FFA    * reserve d1 bytes
       
* release memory in transient area

L03032 MOVEA.L A2,A0
       ADDA.L  $0004(A2),A0
       MOVE.L  (A0),D3
       CMP.L   D1,D3
       BGT.S   L0304E
       MOVE.L  $0004(A0),D3
       BEQ.S   L03048
       ADD.L   A0,D3
       SUB.L   A2,D3
L03048 MOVE.L  D3,$0004(A2)
       BRA.S   L03056

L0304E SUB.L   D1,D3
       MOVE.L  D3,(A0)
       ADDA.L  D3,A0
       MOVE.L  D1,(A0)
L03056 MOVEQ   #$00,D0
       RTS

L0305A ADDQ.W  #4,A7
       RTS

* MT.FREE find largest free space
L0305E MOVE.L  (A0),D1
       LEA     $0008(A6),A1  * SV.CHPFR
       JSR     L0315E(PC)
       MOVE.L  (A1),D2
       ADDA.L  D2,A1
       CMPA.L  $000C(A6),A1  * SV.FREE
       BNE.S   L03088
       MOVE.L  D2,D1
       JSR     L03282(PC)
       SUB.L   D1,D2
       BEQ.S   L03084
       ADDA.L  $0004(A2),A2
       MOVE.L  D2,(A2)
       BRA.S   L03088

L03084 CLR.L   $0004(A2)
L03088 MOVEQ   #$00,D0
       RTS

* RELEASE MEMORY
L0308C MOVE.L  (A0),D1
       LEA     $0018(A6),A1   * SV.TRNFR
       JSR     L0315E(PC)
       LEA     $0014(A6),A2   * SV.TRNSP
       ADDA.L  $0004(A2),A2
       CMPA.L  $0014(A6),A2
       BNE.S   L030DE
       MOVE.L  $0004(A2),-(A7)
       MOVE.L  (A2),D2
       MOVE.L  D2,D1
       JSR     L031C8(PC)     * Release memory
       ADD.L   D1,$0014(A6)   * SV.TRNSP
       SUB.L   D1,D2
       BEQ.S   L030D2
       MOVEA.L (A7)+,A1
       ADDA.L  D1,A2
       ADD.L   D1,$0018(A6)   * SV.TRNFR
       MOVE.L  D2,(A2)
       CLR.L   $0008(A2)
       MOVE.L  A1,$0004(A2)
       BEQ.S   L030DE
       SUB.L   D1,$0004(A2)
       BRA.S   L030DE

L030D2 MOVE.L  (A7)+,D2
       BEQ.S   L030DA
       ADD.L   $0018(A6),D2   * SV.TRNFR
L030DA MOVE.L  D2,$0018(A6)
L030DE RTS


L030E0 
XLtr1d06 EQU L030E0
       MOVEQ   #$01,D0
       MOVEQ   #$00,D1
       LEA     $0018(A6),A0   * SV.TRNFR
       JSR     L03134(PC)
       MOVEA.L $0010(A6),A0   * SV.BASIC
       SUBA.W  #$0200,A0
       SUBA.L  $000C(A6),A0   * SV.FREE
       MOVE.L  A0,D1
       CMP.L   D1,D2
       BLE.S   L03100
       MOVE.L  D2,D1
L03100 BRA     L003A4

L03104 MOVEQ   #$07,D2    * MM.ALLOC
L03106 MOVEQ   #$00,D0
       JSR     L03134(PC)
       CMP.L   D1,D2
       BEQ.S   L03122
       BGT.S   L03116
       MOVEQ   #-$03,D0
       RTS

L03116 ADD.L   D1,$0004(A1)
       MOVEA.L A0,A1
       ADDA.L  D1,A1
       SUB.L   D1,D3
       MOVE.L  D3,(A1)
L03122 MOVE.L  $0004(A0),D2
       BEQ.S   L0312C
       ADD.L   A0,D2
       SUB.L   A1,D2
L0312C MOVE.L  D2,$0004(A1)
       MOVE.L  D1,(A0)
       RTS

* general memory allocation

L03134 SUBQ.W  #4,A0
       ADD.L   D2,D1
       NOT.B   D2
       AND.B   D2,D1
       MOVEQ   #$00,D2
       MOVEA.L D2,A2
L03140 MOVEA.L A0,A1
       MOVE.L  $0004(A0),D3
       BEQ.S   L0315C
       ADDA.L  D3,A0
       MOVE.L  (A0),D3
       CMP.L   D1,D3
       BLT.S   L03140
       MOVEA.L A1,A2
       CMP.L   D2,D3
       BLE.S   L03158
       MOVE.L  D3,D2
L03158 TST.B   D0
       BNE.S   L03140
L0315C RTS

* link free space to task

L0315E CLR.L   $0008(A0)
L03162 SUBQ.W  #4,A1     * MM.LINKFR
       SUBA.L  A2,A2
L03166 MOVEA.L A2,A3
       MOVEA.L A1,A2
       MOVE.L  $0004(A1),D2
       BEQ.S   L0317A
       ADDA.L  D2,A1
       CMPA.L  A0,A1
       BLE.S   L03166
       SUBA.L  A0,A1
       BRA.S   L0317C

L0317A MOVEA.L D2,A1
L0317C MOVE.L  A0,D2
       SUB.L   A2,D2
       MOVE.L  D2,$0004(A2)
       MOVE.L  D1,(A0)+
       MOVE.L  A1,(A0)
L03188 MOVEA.L A2,A1
       MOVEA.L A3,A2
L0318C MOVE.L  $0004(A1),D2
       BEQ.S   L031B6
       MOVEA.L A2,A3
       MOVEA.L A1,A2
       ADDA.L  D2,A1
       MOVE.L  A3,D2
       BEQ.S   L0318C
       MOVE.L  (A2),D2
       ADD.L   A2,D2
       CMP.L   A1,D2
       BNE.S   L0318C
       MOVE.L  $0004(A1),D2
       BEQ.S   L031AC
       ADD.L   (A2),D2
L031AC MOVE.L  D2,$0004(A2)
       MOVE.L  (A1),D2
       ADD.L   D2,(A2)
       BRA.S   L03188

L031B6 RTS

* test against memory Base
* used to allocate memory
L031B8 JSR     L0323A(PC)
       BNE.S   L031DE
       BSR.S   L031E0
L031C0 MOVE.L  (A1)+,(A0)+
       SUBQ.L  #4,D0
       BNE.S   L031C0
       BRA.S   L031DE

* test against top of memory
* used to Release memory
L031C8 JSR     L03276(PC)
       NEG.L   D1
       BEQ.S   L031DE
       BSR.S   L031E0
       NEG.L   D1
       ADDA.L  D0,A0
       ADDA.L  D0,A1
L031D8 MOVE.L  -(A1),-(A0)
       SUBQ.L  #4,D0
       BNE.S   L031D8
L031DE RTS

* update A6 and A7 for Basic

L031E0 MOVEA.L $0068(A6),A3  * SV.JBBAS
       MOVE.L  A0,(A3)
       ADDA.L  D1,A0
       SUB.L   D1,$0058(A0)
       SUB.L   D1,$005C(A0)
       MOVEA.L A0,A1
       SUBA.L  D1,A0
       MOVE.L  $0014(A6),D0
       SUB.L   A1,D0
       CMPA.L  $0064(A6),A3  * SV.JBPNT
       BNE.S   L0320A
       SUB.L   D1,$0008(A5)
       MOVE.L  USP,A3
       SUBA.L  D1,A3
       MOVE.L  A3,USP
L0320A RTS


L0320C ADDI.L  #$1FF,D1    * 512 Bytes round
L03212 ANDI.W  #$FE00,D1
       RTS

* calculate new position of server block

L03218 MOVEA.L $0010(A6),A0  * SV.BASIC
       MOVEQ   #-$08,D3
       BRA.S   L03226

L03220 MOVEA.L $000C(A6),A0  * SV.FREE
       MOVEQ   #$08,D3
L03226 MOVE.L  A0,D0
       SUB.L   A6,D0
       LSR.L   #6,D0
       MOVEA.L $0058(A6),A1   * SV.BTBAS
       ADDA.W  D0,A1
       MOVE.L  D1,D0
       LSR.L   #6,D0
       LSR.L   #3,D0
       RTS

* update server block

L0323A BSR.S   L0320C
       BSR.S   L03218
       SUBA.L  D1,A0
       CMPA.L  $000C(A6),A0  * SV.FREE
       BLE.S   L0329E
       MOVE.L  A0,$0010(A6)  * SV.BASIC
       ADDA.L  D3,A1
       BRA.S   L03270

L0324E BSR.S   L0320C
       BSR.S   L03220
       ADDA.L  D1,A0
       CMPA.L  $0010(A6),A0
       BGE.S   L0329E
       MOVE.L  A0,$000C(A6)
       BRA.S   L03270

L03260 MOVEQ   #$0C,D2
       AND.B   (A1),D2
       BEQ.S   L0326C
       JSR     L0352A(PC)
       BRA.S   L03260
L0326C CLR.B   (A1)
       ADDA.W  D3,A1
L03270 DBF     D0,L03260

       BRA.S   L0329A

L03276 BSR.S   L03212
       BSR.S   L03218
       ADDA.L  D1,A0
       MOVE.L  A0,$0010(A6)
       BRA.S   L03296

L03282 BSR.S   L03212
       BSR.S   L03220
       SUBA.L  D1,A0
       MOVE.L  A0,$000C(A6)   * SV.FREE
       SUBA.W  D3,A1
       BRA.S   L03296

L03290 MOVE.B  #$01,(A1)
       SUBA.W  D3,A1
L03296 DBF     D0,L03290
L0329A MOVEQ   #$00,D0
       BRA.S   L032A0

L0329E MOVEQ   #-$03,D0    * OUT OF MEMORY
L032A0 RTS


* trap 2 dispatch
L032A2 MOVEA.L $0064(A6),A1  * SV.JBPNT
       MOVEA.L (A1),A1
       BCLR    #$07,$0016(A1)
       BEQ.S   L032B4
       ADDA.L  $0008(A5),A0
L032B4 SUBQ.B  #1,D0
       BEQ.S   L032D0      * open
       SUBQ.B  #1,D0
       BEQ     L03352      * close
       SUBQ.W  #1,D0
       BEQ     L036B6      * format
       SUBQ.W  #1,D0
       BEQ     L03552      * delete
       MOVEQ   #-$0F,D0    * bad parameter
       BRA     L003A6


* trap2, open
L032D0 MOVEM.L A1-A4,-(A7)
       MOVEA.L A0,A1
       JSR     L003BC(PC)    * returns bas addr. in A0, jobid in d1
       EXG     A1,A0
       MOVEA.L $0078(A6),A3  * SV.CHBAS
L032E0 TST.B   (A3)          * find free entry in chan table
       BLT.S   L032F0
       ADDQ.W  #4,A3
       CMPA.L  $007C(A6),A3  * SV.CHTOP
       BLT.S   L032E0
       MOVEQ   #-$06,D0
       BRA.S   L0334C

L032F0 MOVEA.L $0044(A6),A2      * SV.DRLIST
L032F4 MOVEM.L D1-D7/A1-A6,-(A7)
       LEA     -$0018(A2),A3
       MOVEA.L $0008(A2),A4
       JSR     (A4)
       MOVEM.L (A7)+,D1-D7/A1-A6
       TST.L   D0
       BEQ.S   L0331E
       CMPI.W  #$FFF9,D0
       BNE.S   L0334C
       MOVEA.L (A2),A2
       MOVE.L  A2,D0
       BGT.S   L032F4
       JSR     L0355A(PC)           * try directory drivers
       TST.L   D0
       BNE.S   L0334C

* chanel opened without error

L0331E MOVE.L  A0,(A3)
       MOVE.W  $0070(A6),D2   * SV.CHTAG
       ADDQ.W  #1,$0070(A6)
       ADDQ.W  #4,A0
       MOVE.L  A2,(A0)+
       MOVE.L  D1,(A0)+
       MOVE.L  A3,(A0)+
       MOVE.W  D2,(A0)+
       CLR.W   (A0)+
       CLR.L   (A0)+
       SWAP    D2
       SUBA.L  $0078(A6),A3   * SV.CHBAS
       MOVE.W  A3,D2
       LSR.W   #2,D2
       MOVEA.L D2,A0
       CMP.W   $0072(A6),D2   * SV.CHMAX
       BLS.S   L0334C
       MOVE.W  D2,$0072(A6)   * SV.CHMAX
L0334C MOVEM.L (A7)+,A1-A4
       BRA.S   L03378

* maintain channel closing trap 2, d0 = 2
* close channel a0
L03352 MOVE.L  A0,D7
       JSR     L03476(PC)           * channel base ->a0
       MOVEM.L D1-D7/A1-A6,-(A7)
       MOVEA.L $0004(A0),A4
       LEA     -$0018(A4),A3
       MOVEA.L $000C(A4),A4
       JSR     (A4)
       MOVEM.L (A7)+,D1-D7/A1-A6
       LSL.W   #2,D7
       MOVEA.L $0078(A6),A0  * SV.CHBAS
       ADDA.W  D7,A0
       ST      (A0)
L03378 BRA     L003A6               * invalidate table entry

* do trap #3 call
* see also L03480
L0337C MOVE.L  A0,D7
       JSR     L03476(PC)   * channel base ->a0
       TAS     $0012(A0)    * CH.STAT
       BNE     L03414       * blocked ->
       MOVEM.L D2-D7/A2-A6,-(A7)
       CLR.L   -(A7)            * a6 relative offset
       ANDI.L  #$0000007F,D0
       CMPI.B  #$49,D0
       BGT.S   L033B0
       CMPI.B  #$46,D0
       BGE.S   L033AE
       CMPI.B  #$07,D0
       BGT.S   L033B0
       BTST    #$01,D0
       BEQ.S   L033B0
L033AE MOVEQ   #$00,D1
L033B0 MOVEA.L $0064(A6),A3     * SV.JBPNT
       MOVEA.L (A3),A3
       BCLR    #$07,$0016(A3)   * tst&clear trap#4 bit
       BEQ.S   L033C4
       MOVE.L  $0008(A5),(A7)
       ADDA.L  (A7),A1          * adjust for a6 relative
L033C4 MOVEA.L $0004(A0),A4     * CH.DRIVR
       MOVE.B  D0,$0013(A0)     * CH.ACTN
       MOVEQ   #$00,D3          * 1st call
       LEA     -$0018(A4),A3
       MOVEA.L $0004(A4),A4
       JSR     (A4)             * do the I/O
       SUBA.L  (A7),A1
       CMPI.W  #-1,D0           * err.nc?
       BNE.S   L03422
       MOVE.W  $000A(A7),D3
       BEQ.S   L03422           * tmout=0 -> return error
       MOVEA.L $002C(A7),A6     * restore SYS.BASE
       JSR     L00408(PC)       * current jobid,jobheader=d0,a3
       MOVE.L  D0,$0014(A0)     * channel busy with CH.JOBW
       LEA     $0012(A0),A0     * CH.STAT
       TST.L   (A7)+            * already set?
       BNE.S   L033FC
       ST      (A0)             * no: channel busy
L033FC MOVE.L  A0,$000C(A3)     * JOB.HOLD
       MOVE.W  D3,$0014(A3)     * JOB.STAT=timeout
       SF      $0012(A3)        * clear accumulated priority
       MOVEQ   #-$01,D0
       MOVEM.L (A7)+,D2-D7/A2-A6
L0340E MOVEA.L D7,A0
       BRA     L00936

L03414 TST.W   D3                   * timeout ?
       BEQ.S   L0341E               * -> return
       SUBQ.L  #2,$000E(A7)         * adjust jobs PC before the trap#3
       BRA.S   L0340E               * since channel blocked by other job

L0341E MOVEQ   #-$01,D0
       BRA.S   L0342C

L03422 ADDQ.W  #4,A7
       MOVEM.L (A7)+,D2-D7/A2-A6
       SF      $0012(A0)    * clear CH.STAT
L0342C MOVEA.L D7,A0
       BRA     L003A6

* trap 4 execution

L03432 MOVE.L  A3,-(A7)
       MOVEA.L $0064(A6),A3  * SV.JBPNT
       MOVEA.L (A3),A3
       TAS     $0016(A3)
       MOVEA.L (A7)+,A3
       BRA     L003A6

* verify that channel exists and find its base

L03444 MOVE.L  A0,-(A7)
       MOVE.L  D0,-(A7)
L03448 MOVE.L  A0,D0
       CMP.W   $0072(A6),D0   * SV.CHMAX
       BHI.S   L0346E
       LSL.W   #2,D0
       MOVEA.L $0078(A6),A0   * SV.CHBAS
       ADDA.W  D0,A0
       TST.B   (A0)
       BLT.S   L0346E
       MOVEA.L (A0),A0
       SWAP    D0
       CMP.W   $0010(A0),D0    * CH.TAG
       BNE.S   L0346E
       MOVE.L  (A7)+,D0
       ADDQ.W  #4,A7
       CMP.B   D0,D0  * sets equ-flag
L0346C RTS

L0346E ADDQ.W  #4,A7
       MOVEQ   #-$06,D0     * channel not open
       MOVEA.L (A7)+,A0
       RTS

L03476 BSR.S   L03444
       BEQ.S   L0346C
       ADDQ.W  #4,A7
       BRA     L003A6

L03480
       DC.L    0        * no more scheduler tasks
       DC.L    L03488   * adress of task
       
L03488 MOVEA.L $0074(A6),A1   * test for pending I/O on any channel
       MOVEA.W $0072(A6),A2   * SV.CHMAX
       ADDA.W  A2,A2
       ADDA.W  A2,A2
       ADDA.L  $0078(A6),A2
       MOVEA.L A1,A3
L0349A ADDQ.W  #4,A1          * loop
       CMPA.L  A2,A1
       BLE.S   L034A4
       MOVEA.L $0078(A6),A1
L034A4 TST.B   (A1)           * valid entry ?
       BLT.S   L034B0
       MOVEA.L (A1),A0
       MOVE.B  $0012(A0),D4   * channel busy ?
       BNE.S   L034B6         * -> work
L034B0 CMPA.L  A1,A3
       BNE.S   L0349A
       BRA.S   L03522         * rts

L034B6 MOVE.L  A1,$0074(A6)  * SV.CHPNT
       MOVE.L  $0014(A0),D1  * CH.JOBWT
       LSL.W   #2,D1
       MOVEA.L $0068(A6),A4  * SV.JBBAS
       ADDA.W  D1,A4
       TST.B   (A4)
       BLT.S   L03524
       MOVEA.L (A4),A4       * JOB.BASE
       SWAP    D1
       CMP.W   $0010(A4),D1  * JOB.TAG
       BLT.S   L03524
       MOVEQ   #$00,D0           * prepare for trap#3  restart
       MOVE.B  $0013(A0),D0      * CH.ACTN
       MOVEQ   #-$01,D3          * restarted call
       MOVEM.L $0024(A4),D1-D2
       MOVEM.L $0044(A4),A1-A2
       MOVE.L  A4,-(A7)
       CLR.L   -(A7)
       ADDQ.B  #1,D4
       BEQ.S   L034F6            * -> not A6 relative
       MOVE.L  $0058(A4),(A7)    * job.a6
       ADDA.L  (A7),A1
L034F6 MOVEA.L $0004(A0),A4
       LEA     -$0018(A4),A3
       MOVEA.L $0004(A4),A4
       JSR     (A4)
       SUBA.L  (A7)+,A1          * adjust relative
       MOVEA.L (A7)+,A4          * JOB.BASE
       MOVE.L  D1,$0024(A4)
       MOVE.L  A1,$0044(A4)
       CMPI.B  #-1,D0
       BEQ.S   L03522
       MOVE.L  D0,$0020(A4)      * set D0 of job
       CLR.B   $0012(A0)         * CH.STAT
       CLR.W   $0014(A4)         * JOB.STAT
L03522 RTS

L03524 CLR.B   $0012(A0)    * CH.STAT
       RTS


* MDV_Motor on
L0352A MOVEM.L D0-D3/A0-A4,-(A7)
       MOVEQ   #$00,D1
       MOVE.B  (A1),D1
       LSR.B   #4,D1
       LSL.B   #2,D1
       LEA     $0100(A6),A2    * SV.FSDEF
       MOVEA.L $00(A2,D1.W),A2
       MOVEA.L $0010(A2),A4
       LEA     -$0018(A4),A3
       MOVEA.L $0010(A4),A4
       JSR     (A4)
       MOVEM.L (A7)+,D0-D3/A0-A4
       RTS


*#: delete file
L03552 ST      D3
       BSR.S   L03564
       BRA     L003A6


*#: open DDEV channel
L0355A CMPI.B  #$04,D3          * -1,4
       BLS.S   L03564
       MOVEQ   #-$0F,D0
       RTS

L03564 MOVEM.L D1-D6/A3-A6,-(A7)
       MOVEA.L A0,A5
       MOVE.L  #$00A0,D1
       JSR     L02FAE(PC)       * MM.ALCHP
       BNE     L0368A
       ADDA.W  #$0018,A0
       LEA     $0140(A6),A1     * SV.FSLIST
       JSR     L039DC(PC)       * UT.LINK
       LEA     (A5),A1          * ???
       JSR     L036D4(PC)
       BNE     L0366E           * error: unlink, dealloc

       MOVEQ   #$0F,D2          * counter 16
       MOVEQ   #-$01,D0
       LEA     $0140(A6),A4     * SV.FSDEF+$40

L03596 MOVE.L  -(A4),D3
       BNE.S   L0359E
       MOVE.W  D2,D0            * remember free place
       BRA.S   L035AC           * next
L0359E MOVEA.L D3,A1
       CMP.B   $0014(A1),D1     * drive# =?
       BNE.S   L035AC
       CMPA.L  $0010(A1),A2     * this driver ?
       BEQ.S   L035DC
L035AC DBF     D2,L03596

       MOVE.W  D0,D2            * found free pointer ?
       BLT     L0366C
       MOVEM.L D1-D2/A0/A2,-(A7)    * alloc new drive def block
       MOVE.L  $0020(A2),D1
       JSR     L02FAE(PC)   * MM.ALCHP
       MOVEM.L (A7)+,D1-D2/A1-A2
       EXG     A1,A0
       BNE     L0366E
       MOVE.L  A2,$0010(A1)     * driver
       MOVE.B  D1,$0014(A1)     * drive#
       MOVE.W  D2,D0
       LSL.W   #2,D0
       ADDA.W  D0,A4
       MOVE.L  A1,(A4)          * set SV.FSDEF table entry

L035DC MOVE.B  D2,$0005(A0)     * chdef+$18+$5
       MOVE.B  $000B(A7),$0004(A0)  * delete(-1) or D3 code
       LEA     $001A(A0),A4     * +$18, save name in channel defblock
       MOVE.W  (A5)+,D0
       MOVE.W  $0024(A2),D3
       ADDQ.W  #2,D3            * drv namelen
       ADDA.W  D3,A5
       SUB.W   D3,D0
       BLT.S   L03660
       CMPI.W  #$0024,D0        * maxlen 36 + drive#_
       BGT.S   L03660
       MOVE.W  D0,(A4)+
       BRA.S   L03604

L03602 MOVE.B  (A5)+,(A4)+      * copy name
L03604 DBF     D0,L03602
       MOVEA.L A1,A5
       MOVEA.L A0,A1
L0360C MOVEA.L (A1),A1          * next linked  channel
       MOVE.L  A1,D0
       BEQ.S   L03652           * no more ..., find file
       CMP.B   $0005(A1),D2     * same drive?
       BNE.S   L0360C
       MOVEQ   #$01,D0          * compare file names
       MOVEA.W #$001A,A6            * name offset
       JSR     L03A9C(PC)           * UT.CSTR
       MOVEA.L $0024(A7),A6         * restore
       BNE.S   L0360C               * not same file

       CMPI.B  #$02,$0004(A0)
       BEQ.S   L03664               * already exists
       CMPI.B  #$01,$0004(A0)
       BNE.S   L03668               * in use
       CMPI.B  #$01,$0004(A1)
       BNE.S   L03668
       MOVE.W  $0006(A1),$0006(A0)  * read only, copy info
       MOVE.L  $000C(A1),$000C(A0)
       MOVE.W  #$0040,$000A(A0)
L03652 MOVEA.L A5,A1                * drive def
       TST.W   $0006(A0)            * file already located ?
       BEQ.S   L03690               * -> no, find it
       SUBA.W  #$0018,A0
       BRA.S   L03684               * ok, return

L03660 MOVEQ   #-$0C,D0
       BRA.S   L0366E

L03664 MOVEQ   #-$08,D0
       BRA.S   L0366E

L03668 MOVEQ   #-$09,D0
       BRA.S   L0366E

L0366C MOVEQ   #-$06,D0
L0366E LEA     $0140(A6),A1  * SV.FSLST
       JSR     L039E2(PC)    * UT.UNLNK
       SUBA.W  #$0018,A0
       MOVE.L  D0,D4
       JSR     L0305E(PC)    * MT.RECHP
       MOVE.L  D4,D0
       BRA.S   L0368A

L03684 ADDQ.B  #1,$0022(A1)
       MOVEQ   #$00,D0
L0368A MOVEM.L (A7)+,D1-D6/A3-A6
       RTS
       

*#: call ddev_open
L03690 SUBA.W  #$0018,A0            *
       MOVE.L  A1,-(A7)
       MOVE.L  A2,-(A7)
       LEA     -$0018(A2),A3
       MOVEA.L $0008(A2),A4
       JSR     (A4)
       MOVEA.L (A7)+,A2
       MOVEA.L (A7)+,A1
       TST.B   $001C(A0)            * delete file ?
       BLT.S   L036B0
       TST.L   D0
       BEQ.S   L03684               * success
L036B0 ADDA.W  #$0018,A0
       BRA.S   L0366E               * return D0


*#: FORMAT SECTORED MEDIUM
L036B6 MOVEM.L D3-D7/A1-A5,-(A7)
       MOVEA.L A0,A1
       JSR     L036D4(PC)
       BLT.S   L036CC
       LEA     -$0018(A2),A3
       MOVEA.L $001C(A2),A4
       JSR     (A4)                 * dev_format
L036CC MOVEM.L (A7)+,D3-D7/A1-A5
       BRA     L003A6


* VERIFY NAME
*#: find drive a1=file_name< >a2 driver > d1=drive#num
L036D4 MOVEM.L A1/A4,-(A7)
       MOVEA.L $0048(A6),A2   * SV.DDLST
L036DC LEA     $0024(A2),A4   * DRIVE namelen
       MOVE.W  (A4)+,D0
       MOVEA.L (A7),A1
       ADDQ.W  #2,A1
L036E6 MOVE.B  (A1)+,D1
       BCLR    #$05,D1        * uppercase
       CMP.B   (A4)+,D1
       BNE.S   L036F6         * try next driver
       SUBQ.W  #1,D0
       BGT.S   L036E6
       BRA.S   L036FE         * drive name matches

L036F6 MOVEA.L (A2),A2
       MOVE.L  A2,D0          * next driver
       BNE.S   L036DC
       BRA.S   L03718         * no more drivers

L036FE MOVEQ   #$00,D1
       MOVE.B  (A1)+,D1
       SUBI.B  #$30,D1        * 1<=drive number<=8
       BLE.S   L03718
       CMPI.B  #$09,D1
       BGE.S   L03718
       CMPI.B  #$5F,(A1)      * '_'
       BNE.S   L03718
       MOVEQ   #$00,D0
       BRA.S   L0371A         * ok, rts

L03718 MOVEQ   #-$07,D0
L0371A MOVEM.L (A7)+,A1/A4
       RTS


*#: a2= (a2+1)& (not 1)
L03720 MOVE.L  A2,D2
       ADDQ.L  #1,D2
       BCLR    #$00,D2
       MOVEA.L D2,A2
       RTS


* ANALYSE SYNTAX
L0372C MOVEA.L (A7),A2              * IO.DECODE
       ADDQ.W  #6,A2
       MOVEM.L D4/D7/A0/A3,-(A7)
       MOVEQ   #$00,D7
       MOVE.W  (A0)+,D7
       ADD.L   A0,D7
       MOVE.W  (A2)+,D2
L0373C BSR.S   L037B6
       CMP.B   (A2)+,D1
       BNE.S   L037A6
       SUBQ.B  #1,D2
       BNE.S   L0373C
       BSR.S   L03720
       MOVE.W  (A2)+,D4
       BRA.S   L03790

L0374C BSR.S   L03720
       MOVE.B  (A2)+,D1
       BEQ.S   L03778
       BLT.S   L03760
       BSR.S   L037B6
       CMP.B   (A2)+,D1
       BEQ.S   L03762
       SUBQ.W  #1,A0
       MOVE.W  (A2)+,(A3)+
       BRA.S   L03790

L03760 ADDQ.W  #1,A2
L03762 MOVEA.L A7,A1
       MOVE.W  (A2)+,-(A7)
       SUBA.L  A6,A0
       SUBA.L  A6,A1
       SUB.L   A6,D7
       JSR     L03DC2(PC)
       ADDA.L  A6,A0
       ADD.L   A6,D7
       MOVE.W  (A7)+,(A3)+
       BRA.S   L03790

L03778 MOVE.B  (A2)+,D2
       EXT.W   D2
L0377C ADDA.W  D2,A2   * IO.SERQ
       MOVE.L  A2,-(A7)
       BSR.S   L037B6
L03782 CMP.B   -(A2),D1
       BEQ.S   L0378C
       SUBQ.W  #1,D2
       BNE.S   L03782
       SUBQ.W  #1,A0
L0378C MOVE.W  D2,(A3)+
       MOVEA.L (A7)+,A2
L03790 DBF     D4,L0374C
       CMP.L   A0,D7
       BNE.S   L0379C
       MOVEQ   #$04,D1
       BRA.S   L037AE

L0379C MOVEM.L (A7)+,D4/D7/A0/A3
       ADDQ.L  #2,(A7)
       MOVEQ   #-$0C,D0
       RTS

L037A6 MOVEM.L (A7)+,D4/D7/A0/A3
       MOVEQ   #-$07,D0
       RTS

L037AE MOVEM.L (A7)+,D4/D7/A0/A3
       ADDQ.L  #4,(A7)
       RTS

L037B6 MOVEQ   #$00,D1
       CMP.L   A0,D7
       BEQ.S   L037C8
       MOVE.B  (A0),D1
       CMPI.B  #$60,D1
       BLT.S   L037C8
       SUBI.B  #$20,D1
L037C8 ADDQ.W  #1,A0
       RTS


* DIRECT FILE HANDLING
* queue routines
L037CC LEA     $0018(A0),A2   * pipe#  I / O
       CMPI.B  #$03,D0
       BLS.S   L037D8
       ADDQ.W  #4,A2
L037D8 TST.L   (A2)
       BEQ.S   L037F0
       MOVEA.L (A2),A2
       JSR     L0388C(PC)    * IO.SERIO
       DC.L    XL0380A       * ROUTINE TEST FILE
       DC.L    XL0385E       * READ FROM PIPE
       DC.L    XL03838       * WRITE TO PIPE
       RTS

L037F0 MOVEQ   #-$0F,D0
       RTS


L037F4 LEA     $10(A2,D1.W),A3  * IO.QSET
       CLR.L   (A2)+
       MOVE.L  A3,(A2)+
       SUBQ.W  #1,A3
       MOVE.L  A3,(A2)+
       MOVE.L  A3,(A2)+
       SUBA.L  #$10,A2
       RTS


* test status of queue
L0380A 
XL0380A EQU L0380A
       MOVEQ   #-$11,D2         * IO.QTEST
       ADD.L   $0004(A2),D2
       SUB.L   A2,D2
       MOVE.L  $0008(A2),D0
       MOVEA.L $000C(A2),A3
       MOVE.B  (A3),D1
       SUB.L   A3,D0
       BGT.S   L03832
       BLT.S   L0382E
       TST.B   (A2)
       BLT.S   L0382A
       MOVEQ   #-$01,D0
       RTS

L0382A MOVEQ   #-$0A,D0
       RTS

L0382E ADD.L   D2,D0
       ADDQ.L  #1,D0
L03832 SUB.L   D0,D2
       MOVEQ   #$00,D0
       RTS

* put byte into queue
* Vector EA
L03838 
XL03838 EQU L03838
       TST.B   (A2)          * IO.QIN
       BNE.S   L0385A
       MOVEA.L $0008(A2),A3
       MOVE.B  D1,(A3)+
       CMPA.L  $0004(A2),A3
       BLT.S   L0384C
       LEA     $0010(A2),A3
L0384C CMPA.L  $000C(A2),A3
       BNE.S   L03856
       MOVEQ   #-$01,D0
       RTS

L03856 MOVE.L  A3,$0008(A2)
L0385A MOVEQ   #$00,D0
       RTS

* Vector E2 + WRITE TO PIPE

L0385E 
XL0385E EQU L0385E
       MOVEA.L $000C(A2),A3     * IO.QOUT
       CMPA.L  $0008(A2),A3
       BNE.S   L03874
       TST.B   (A2)
       BLT.S   L03870
       MOVEQ   #-$01,D0
       RTS

L03870 MOVEQ   #-$0A,D0
       RTS

L03874 MOVE.B  (A3)+,D1
       CMPA.L  $0004(A2),A3
       BLT.S   L03880
       LEA     $0010(A2),A3
L03880 MOVE.L  A3,$000C(A2)
       MOVEQ   #$00,D0
       RTS

L03882 EQU L03880+2

L03888 TAS     (A2)             * IO.QEOF
       RTS

* Vector EA

L0388C ADDI.L  #$0000000C,(A7)   * IO.SERIO - d0 as trap 3
       MOVEA.L (A7),A4
       MOVE.L  D2,D4
       MOVE.L  D1,D5
       CMPI.W  #$0045,D0
       BHI.S   L038B2
       CMPI.W  #$0007,D0
       BHI.S   L03914
       ANDI.L  #$0000FFFF,D4
       MOVE.B  L038C0(PC,D0.W),D0
       JMP     L038C0(PC,D0.W)
       
L038B2 CMPI.B  #$49,D0
       BHI.S   L03914
       MOVE.B  L038C0-$3E(PC,D0.W),D0
       JMP     L038C0(PC,D0.W)

L038C0 DC.B    XL0390A-L038C0
       DC.B    XL0390C-L038C0
       DC.B    XL038CC-L038C0
       DC.B    XL038F8-L038C0
       DC.B    XL03914-L038C0
       DC.B    XL0390E-L038C0
       DC.B    XL03914-L038C0
       DC.B    XL038E4-L038C0
       DC.B    XL03930-L038C0
       DC.B    XL03944-L038C0
       DC.B    XL038F8-L038C0
       DC.B    XL038E4-L038C0
       
L038CC MOVE.L  -$0008(A4),A4
XL038CC EQU L038CC
L038D0 CMP.L   D5,D4
       BLS.S   L03918
       BSR.S   L03922
       BNE.S   L0391E
       MOVE.B  D1,(A1)+
       ADDQ.L  #1,D5
       CMPI.B  #$0A,D1
       BNE.S   L038D0
       BRA.S   L0391E

L038E4 MOVEA.L -$0004(A4),A4
L038E8 CMP.L   D5,D4
       BLS.S   L0391C
       MOVE.B  (A1),D1
       BSR.S   L03922
       BNE.S   L0391E
       ADDQ.W  #1,A1
       ADDQ.L  #1,D5
       BRA.S   L038E8

XL038E4 EQU L038E4

L038F8 MOVEA.L -$0008(A4),A4
XL038F8 EQU L038F8
L038FC CMP.L   D5,D4
       BLS.S   L0391C
       BSR.S   L03922
       BNE.S   L0391E
       MOVE.B  D1,(A1)+
       ADDQ.L  #1,D5
       BRA.S   L038FC

L0390A SUBQ.W  #4,A4
L0390C SUBQ.W  #4,A4
L0390E MOVEA.L -$0004(A4),A4
       BRA.S   L03922
       
XL0390A EQU L0390A
XL0390C EQU L0390C
XL0390E EQU L0390E

L03914 MOVEQ   #-$0F,D0
       BRA.S   L0392C
XL03914 EQU L03914
L03918 MOVEQ   #-$05,D0
       BRA.S   L0391E

L0391C MOVEQ   #$00,D0
L0391E MOVE.L  D5,D1
       BRA.S   L0392C

L03922 MOVEM.L D4-D5/A1/A4,-(A7)
       JSR     (A4)
       MOVEM.L (A7)+,D4-D5/A1/A4
L0392C TST.L   D0
       RTS

L03930
XL03930 EQU L03930
       MOVEA.L -$0004(A4),A4
       MOVEQ   #$0F,D4
       TST.W   D5
       BGT.S   L038E8
       ST      D1
       BSR.S   L03922
       BNE.S   L0391E
       MOVEQ   #$01,D5
       BRA.S   L038E8

L03944
XL03944 EQU L03944
       MOVEQ   #$0F,D4
       TST.W   D5
       BGT.S   L038F8
       MOVEA.L -$000C(A4),A4
       BSR.S   L03922
       BNE.S   L0391E
       ADDQ.B  #1,D1
       BNE.S   L03914
       MOVEA.L (A7),A4
       BSR.S   L0390C
       MOVEQ   #$01,D5
       BRA.S   L038FC

L0395E MOVE.L  A0,-(A7)  * UT.ERR0
       SUBA.L  A0,A0
       BSR.S   L03968    * UT.ERR
       MOVEA.L (A7)+,A0
       RTS

L03968 TST.L   D0         * UT.ERR
       BGE.S   L0398E
       MOVEM.L D0-D3/A1,-(A7)
       MOVEA.L D0,A1
       ADD.L   D0,D0
       BVS.S   L03986
       NEG.W   D0
       MOVEA.L $0002814A,A1  * TABLE OF ERROR-MESSAGES 
       MOVE.W  $00(A1,D0.W),D0
       LEA     $00(A1,D0.W),A1
L03986 JSR     L039B2(PC)    * UT.MTEXT
       MOVEM.L (A7)+,D0-D3/A1
L0398E RTS

L03990 MOVE.L  A6,-(A7)  * UT.MINT
       SUBA.L  A6,A6
       MOVEA.L A7,A1
       SUBQ.W  #8,A7
       MOVE.L  A0,-(A7)
       LEA     $0004(A7),A0
       MOVE.W  D1,-(A1)
       JSR     L03E54(PC)   * CN.ITOD
       MOVEA.L (A7)+,A0
       MOVEA.L A7,A1
       MOVE.W  D1,D2
       BSR.S   L039B4
       ADDQ.W  #8,A7
       MOVEA.L (A7)+,A6
       RTS

L039B2 MOVE.W  (A1)+,D2   * UT.MTEXT
L039B4 MOVEQ   #$07,D0
       MOVE.L  A0,D3
       BEQ.S   L039BE
       MOVEQ   #-$01,D3
       BRA.S   L039C4

L039BE SF      $00028033

L039C4 TRAP    #$03
       CMPI.W  #$FFFF,D0
       BNE.S   L039D8
       MOVE.L  #$00010001,A0   * scr#1
       MOVEQ   #$07,D0
       TRAP    #$03
       SUBA.L  A0,A0
L039D8 TST.L   D0
       RTS

* vector d2

L039DC MOVE.L  (A1),(A0)    * UT.LINK
       MOVE.L  A0,(A1)
       RTS

* vector d4

L039E2 CMPA.L  (A1),A0      * UT.UNLNK
       BEQ.S   L039EE
       TST.L   (A1)
       BEQ.S   L039F0
       MOVEA.L (A1),A1
       BRA.S   L039E2

L039EE MOVE.L  (A0),(A1)
L039F0 RTS

L039F2 BSR.S   L03A2A    * UT.WINDW
       BRA.S   L03A0C

L039F6 LEA     L03A44(PC),A0    * UT.CON
       BRA.S   L03A00

L039FC LEA     L03A4A(PC),A0   * UT.SCR
L03A00 BSR.S   L03A2A
L03A02 ADDQ.W  #4,A1
       MOVEQ   #$0D,D0
       MOVEQ   #$00,D2
       BSR.S   L03A36
       SUBQ.W  #4,A1
L03A0C MOVEQ   #$0C,D0
       MOVE.B  (A1)+,D1
       MOVE.B  (A1)+,D2
       BSR.S   L03A36
       MOVEQ   #$27,D0
       MOVE.B  (A1),D1
       BSR.S   L03A36
       MOVEQ   #$28,D0
       MOVE.B  (A1)+,D1
       BSR.S   L03A36
       MOVEQ   #$29,D0
       MOVE.B  (A1),D1
       BSR.S   L03A36
       MOVEQ   #$20,D0
       BRA.S   L03A36

* open window#

L03A2A MOVE.L  A1,-(A7)
       MOVEQ   #$01,D0
       MOVEQ   #-$01,D1
       MOVEQ   #$00,D3
       TRAP    #$02
       BRA.S   L03A3A

* windowtrap

L03A36 MOVE.L  A1,-(A7)
       TRAP    #$03
L03A3A MOVEA.L (A7)+,A1
       TST.L   D0
       BEQ.S   L03A42
       ADDQ.W  #4,A7
L03A42 RTS

L03A44 DC.W    $03
       DC.B    'CON',$00
L03A4A DC.W    $03
       DC.B    'SCR',$00
       
* set pointer for string-compa.

L03A50 MOVEQ   #$00,D4
       MOVE.B  D0,D4
       ROR.L   #1,D4
       SUBQ.B  #2,D4
       MOVE.W  $00(A6,A0.L),D0
       ADDQ.W  #2,A0
       LEA     $00(A0,D0.W),A2
       MOVE.W  $00(A6,A1.L),D1
       ADDQ.W  #2,A1
       LEA     $00(A1,D1.W),A3
       RTS

* find pos of string 2 in string 1

L03A6E MOVEM.L D4/A0-A4,-(A7)
       BSR.S   L03A50
       LEA     $00(A1,D0.W),A4
       EXG     A3,A4
       MOVEQ   #$00,D1
L03A7C CMPA.L  A4,A3
       BGT.S   L03A8C
       ADDQ.L  #1,D1
       BSR.S   L03A96
       BEQ.S   L03A90
       ADDQ.W  #1,A1
       ADDQ.W  #1,A3
       BRA.S   L03A7C

* string comparison

L03A8C MOVEQ   #$00,D1
       MOVEQ   #$00,D0
L03A90 MOVEM.L (A7)+,D4/A0-A4
       RTS

L03A96 MOVEM.L D1-D5/A0-A3,-(A7)
       BRA.S   L03AA2

L03A9C MOVEM.L D1-D5/A0-A3,-(A7)
       BSR.S   L03A50
L03AA2 CMPA.L  A2,A0
       BNE.S   L03AAC
       CMPA.L  A3,A1
       BNE.S   L03AC8
       BRA.S   L03ACC

L03AAC CMPA.L  A3,A1
       BEQ.S   L03AD0
       BSR.S   L03AE8
       CMP.B   D4,D0
       BEQ.S   L03B2C
       CMP.B   D3,D2
       BNE.S   L03AC6
       TST.B   D0
       BLE.S   L03AA2
       TST.L   D4
       BLT.S   L03AA2
       CMPI.B  #$02,D0
L03AC6 BGT.S   L03AD0
L03AC8 MOVEQ   #-$01,D0
       BRA.S   L03AD2

L03ACC MOVEQ   #$00,D0
       BRA.S   L03AD2

L03AD0 MOVEQ   #$01,D0
L03AD2 MOVEM.L (A7)+,D1-D5/A0-A3
       RTS
       
* Table of results of string comparison

L03AD8 DC.W    $0000
       DC.W    $0000
       DC.W    $00FF
       DC.W    $0000
       DC.W    $0000
       DC.W    $0001
       DC.W    $0000
       DC.W    $0300

* compare bytes of string
       
L03AE8 EXG     A0,A1
       EXG     A2,A3
       BSR.S   L03B04
       EXG     A0,A1
       EXG     A2,A3
       MOVE.B  D0,D1
       MOVE.B  D2,D3
       BSR.S   L03B04
       LSL.B   #2,D0
       ADD.B   D1,D0
       EXT.W   D0
       MOVE.B  L03AD8(PC,D0.W),D0
       RTS

* correct decimal values (3.5)

L03B04 MOVE.B  $00(A6,A0.L),D2
       ADDQ.W  #1,A0
       BSR     L03BFA
       CMPI.B  #$CE,D2
       BNE.S   L03B2A
       CMPA.L  A2,A0
       BEQ.S   L03B28
       CMPI.B  #$30,$00(A6,A0.L)
       BLT.S   L03B28
       CMPI.B  #$39,$00(A6,A0.L)
       BLE.S   L03B2A
L03B28 CLR.B   D0
L03B2A RTS

* compare two ASCII numbers

L03B2C BSR.S   L03B96
       MOVE.W  D3,D2
       MOVE.W  D1,D3
       EXG     A0,A1
       EXG     A2,A3
       BSR.S   L03B96
       CMP.W   D1,D3
L03B3A BNE.S   L03AC6
       SUBA.W  D1,A0
       SUBA.W  D1,A1
       BRA.S   L03B50

L03B42 MOVE.B  $00(A6,A1.L),D5
       ADDQ.W  #1,A1
       CMP.B   $00(A6,A0.L),D5
       ADDQ.W  #1,A0
       BNE.S   L03B3A
L03B50 DBF     D1,L03B42
       BSR.S   L03BCC
       MOVE.W  D3,-(A7)
       MOVE.W  D1,-(A7)
       EXG     A0,A1
       EXG     A2,A3
       BSR.S   L03BCC
       MOVE.W  (A7)+,D0
       MOVE.W  (A7)+,D2
       SUB.W   D2,D3
       BGT.S   L03B6A
       ADD.W   D3,D2
L03B6A TST.W   D2
       BEQ.S   L03B8C
       SUBA.W  D1,A0
       SUBA.W  D0,A1
       SUB.W   D2,D1
       SUB.W   D2,D0
L03B76 MOVE.B  $00(A6,A0.L),D5
       ADDQ.W  #1,A0
       CMP.B   $00(A6,A1.L),D5
       ADDQ.W  #1,A1
       BNE.S   L03B3A
       SUBQ.W  #1,D2
       BNE.S   L03B76
       ADDA.W  D1,A0
       ADDA.W  D0,A1
L03B8C TST.W   D3
       BNE     L03AC6
       BRA     L03AA2

L03B96 MOVEQ   #$00,D1
L03B98 CMPI.B  #$D0,D2
       BNE.S   L03BB0
       CMPA.L  A2,A0
       BEQ.S   L03BCA
       MOVE.B  $00(A6,A0.L),D2
       ADDQ.W  #1,A0
       BSR.S   L03BFA
       SUBQ.B  #1,D0
       BNE.S   L03BC8
       BRA.S   L03B98

L03BB0 CMPI.B  #$CE,D2
       BEQ.S   L03BC8
       ADDQ.W  #1,D1
       CMPA.L  A2,A0
       BEQ.S   L03BCA
       MOVE.B  $00(A6,A0.L),D2
       ADDQ.W  #1,A0
       BSR.S   L03BFA
       SUBQ.B  #1,D0
       BEQ.S   L03BB0
L03BC8 SUBQ.W  #1,A0
L03BCA RTS

L03BCC MOVEQ   #$00,D1
       MOVEQ   #$00,D3
L03BD0 CMPA.L  A2,A0
       BEQ.S   L03BF8
       MOVE.B  $00(A6,A0.L),D2
       BSR.S   L03BFA
       SUBQ.B  #1,D0
       BNE.S   L03BF8
       CMPI.B  #$CE,D2
       BNE.S   L03BEA
       TST.L   D1
       BNE.S   L03BF8
       MOVEQ   #-$01,D1
L03BEA ADDQ.W  #1,A0
       ADDQ.W  #1,D1
       CMPI.B  #$D0,D2
       BEQ.S   L03BD0
       MOVE.W  D1,D3
       BRA.S   L03BD0

L03BF8 RTS

L03BFA MOVE.B  D2,D0
       BLT.S   L03C14
       CMPI.B  #$2E,D0
       BEQ.S   L03C18
       EXT.W   D0
       ADDI.W  #XVALUE1,D0
       MOVE.B  L03BFA(PC,D0.W),D0
       BEQ.S   L03C14
       SUBQ.B  #2,D0
       BLE.S   L03C18
L03C14 CLR.B   D0
       RTS

L03C18 MOVE.B  D2,D0
       ADDI.B  #$A0,D2
       BCC.S   L03C24
       SUBI.B  #$20,D2
L03C24 LSR.B   #5,D0
       RTS

* this label defines type of ASCII code
L03C28
XVALUE1 EQU L03C28-L03BFA       
       DC.L    $00000000
       DC.L    $00000000
       DC.L    $00000000
       DC.L    $00000000
       DC.L    $00000000
       DC.L    $00000000
       DC.L    $00000000
       DC.L    $00000000
       DC.L    $20030000
       DC.L    $24250003
       DC.L    $00000000
       DC.L    $03000000
       DC.L    $02020202
       DC.L    $02020202
       DC.L    $02020003
       DC.L    $00000000
       DC.L    $00010101
       DC.L    $01010101
       DC.L    $01010101
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$00
       DC.B    $00,$00,$00,$01
       DC.B    $00,$01,$01,$01
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$01
       DC.B    $01,$01,$01,$00
       DC.B    $00,$00,$00,$00
       
* test sign of number to convert to floating-point number

L03CA8 CMP.L   A0,D7
       BEQ.S   L03CCA
       ADDQ.W  #1,A0
L03CAE CMPI.B  #$20,$00(A6,A0.L)
       BEQ.S   L03CA8
       MOVEQ   #$00,D5
       MOVEQ   #$2B,D6
       SUB.B   $00(A6,A0.L),D6
       BEQ.S   L03CC8
       ADDQ.B  #2,D6
       BNE.S   L03CCA
       BSET    #$1F,D5
L03CC8 ADDQ.W  #1,A0
L03CCA RTS

* convert ASCII to decimal

L03CCC MOVEQ   #$00,D6
       CMP.L   A0,D7
       BEQ.S   L03CEA
       MOVE.B  $00(A6,A0.L),D6
       SUBI.W  #$0030,D6
       BLT.S   L03CE6
       CMPI.W  #$0009,D6
       BGT.S   L03CE6
       ADDQ.L  #2,(A7)
       BRA.S   L03CEA

L03CE6 ADDI.W  #$0030,D6
L03CEA ADDQ.W  #1,A0
       RTS

* convert entire number from ASCII to decimal

L03CEE BSR.S   L03CAE
       BSR.S   L03CCC
       BRA.S   L03D08    * ERROR
L03CF4 MOVE.L  D6,D3
L03CF6 BSR.S   L03CCC
       BRA.S   L03D0C    * ERROR
L03CFA MULU    #$000A,D3
       ADD.L   D6,D3
       CMPI.L  #$00007FFF,D3
       BLE.S   L03CF6
L03D08 MOVEQ   #-$11,D0
       RTS
       
* TEST SIGN + / -

L03D0C TST.L   D5
       BPL.S   L03D12
       NEG.W   D3
L03D12 MOVEQ   #$00,D0
       RTS

* vector 100 - convert ASCII to floating point

L03D16 MOVEM.L D3-D6/A0-A1,-(A7)   * CN.DTOF
       MOVEQ   #$00,D4
       BSR.S   L03CAE
       SUBQ.W  #6,A1
       CLR.L   $02(A6,A1.L)
       CLR.W   $00(A6,A1.L)
L03D28 BSR.S   L03CCC
       BRA.S   L03D48
L03D2C MOVE.B  #$DF,D5   * CN.DTOI
       TST.W   D4
       BEQ.S   L03D36
       ADDQ.W  #1,D4
L03D36 BSR.S   L03DB6
       JSR     L048DE(PC)
       BNE.S   L03DB0
       MOVE.L  D6,D1
       BSR.S   L03DB8
       JSR     L04838(PC)
       BRA.S   L03D28

L03D48 CMPI.B  #$2E,D6
       BNE.S   L03D56
       TST.W   D4
       BNE.S   L03DAE
       MOVEQ   #$01,D4
       BRA.S   L03D28

L03D56 TST.B   D5
       BEQ.S   L03DAE
       TST.L   D5
       BPL.S   L03D62
       JSR     L04A0C(PC)
L03D62 MOVEQ   #$00,D3
       AND.B   D5,D6
       CMPI.B  #$45,D6
       BNE.S   L03D70
       BSR.S   L03CEE
       BNE.S   L03DB0
L03D70 TST.W   D4
       BEQ.S   L03D76
       SUBQ.W  #1,D4
L03D76 SUB.W   D3,D4
       BVS.S   L03DAE
       BEQ.S   L03DA2
       SGE     D5
       BGE.S   L03D82
       NEG.W   D4
L03D82 BSR.S   L03DB6
       SUBQ.W  #2,A1
       MOVE.W  D4,$00(A6,A1.L)
       JSR     L047DC(PC)
       BNE.S   L03DB0
       TST.B   D5
       BEQ.S   L03D9C
       JSR     L0497E(PC)
       BNE.S   L03DB0
       BRA.S   L03DA2

L03D9C JSR     L048DE(PC)
       BNE.S   L03DB0
L03DA2 MOVEM.L (A7)+,D3-D6
       SUBQ.W  #1,A0
       ADDQ.W  #8,A7
       MOVEQ   #$00,D0
       RTS

L03DAE MOVEQ   #-$11,D0
L03DB0 MOVEM.L (A7)+,D3-D6/A0-A1
       RTS

L03DB6 MOVEQ   #$0A,D1
L03DB8 MOVE.L  #$0000081F,D0
       JMP     L04830(PC)

* vector 102 ASCII to int
* CN.DTOI
L03DC2 MOVEM.L D3-D6/A0-A1,-(A7)
       BSR     L03CEE
       BNE.S   L03DB0
       SUBQ.W  #2,A1
       MOVE.W  D3,$00(A6,A1.L)
       BRA.S   L03DA2

* vector 10A

L03DD4 MOVEQ   #$02,D2   * CN.HTOIB
       BRA.S   L03DDE

* vector 10C

L03DD8 MOVEQ   #$04,D2   * CN.HTOIW
       BRA.S   L03DDE

* vector 10E

L03DDC MOVEQ   #$08,D2   * CN.HTOIL
L03DDE MOVEM.L D3-D6/A0-A1,-(A7)
       MOVE.L  D2,D4
       LSR.B   #1,D4
       SUBQ.W  #2,A1
       MOVE.B  D4,$01(A6,A1.L)
       MOVE.B  #$0F,$00(A6,A1.L)
       MOVEQ   #$04,D4
L03DF4 MOVE.L  D2,D5
       MOVEQ   #$00,D3
L03DF8 BSR     L03CCC
       BRA.S   L03E00    * error
       BRA.S   L03E0E    * ok

L03E00 ANDI.B  #$DF,D6
       SUBI.B  #$41,D6
       BLT.S   L03E1E
       ADDI.B  #$0A,D6
L03E0E CMP.B   $00(A6,A1.L),D6
       BHI.S   L03E1E
       LSL.L   D4,D3
       ADD.L   D6,D3
       DBF     D2,L03DF8
       BRA.S   L03E30

L03E1E MOVE.B  $01(A6,A1.L),D4
       ADDQ.L  #2,A1
       MOVE.L  D3,-$04(A6,A1.L)
       SUBA.L  D4,A1
       CMP.W   D2,D5
       BGT     L03DA2
L03E30 BRA     L03DAE

* vector 104

L03E34 MOVEQ   #$08,D2   * CN.BTOIB
       BRA.S   L03E3E

* vector 106

L03E38 MOVEQ   #$10,D2   * CN.BTOIW
       BRA.S   L03E3E

L03E3C MOVEQ   #$20,D2   * CN.BTOIB
L03E3E MOVEM.L D3-D6/A0-A1,-(A7)
       MOVE.L  D2,D4
       LSR.B   #3,D4
       SUBQ.W  #2,A1
       MOVE.B  D4,$01(A6,A1.L)
       MOVEQ   #$01,D4
       MOVE.B  D4,$00(A6,A1.L)
       BRA.S   L03DF4

* vector F2

L03E54 MOVE.L  A2,-(A7)   * CN.ITOD
       MOVE.L  A0,-(A7)
       MOVEQ   #$00,D0
       MOVE.W  $00(A6,A1.L),D0
       ADDQ.W  #2,A1
       BGE.S   L03E6C
       MOVE.B  #$2D,$00(A6,A0.L)

       ADDQ.W  #1,A0
       NEG.W   D0
L03E6C MOVE.L  A0,-(A7)
       ADDQ.W  #5,A0
L03E70 DIVU    #$000A,D0
       SWAP    D0
       ADDI.B  #$30,D0
       SUBQ.W  #1,A0
       MOVE.B  D0,$00(A6,A0.L)
       CLR.W   D0
       SWAP    D0
       BNE.S   L03E70
       MOVE.L  (A7)+,D1
       SUB.L   A0,D1
       MOVE.W  D1,D0
       ADDQ.W  #4,D0
L03E8E LEA     $00(A0,D1.W),A2
       MOVE.B  $00(A6,A0.L),$00(A6,A2.L)
       ADDQ.W  #1,A0
       DBF     D0,L03E8E
       ADD.L   A0,D1
       MOVEA.L D1,A0
       SUB.L   (A7)+,D1
       MOVEA.L (A7)+,A2
       RTS

L03EA8 BSR     L03EAC            * CN.ITOHL
L03EAC BSR     L03EB0            * CN.ITOHW
L03EB0 MOVE.B  $00(A6,A1.L),D0   * CN.ITOHB
       LSR.B   #4,D0
       BSR.S   L03EC0
       MOVEQ   #$0F,D0
       AND.B   $00(A6,A1.L),D0
       ADDQ.W  #1,A1
L03EC0 ADDI.B  #$30,D0
       CMPI.B  #$39,D0
       BLS.S   L03ECC
       ADDQ.B  #7,D0
L03ECC MOVE.B  D0,$00(A6,A0.L)
       ADDQ.W  #1,A0
       RTS

L03ED4 BSR     L03ED8                   * CN.ITOBL  
L03ED8 BSR     L03EDC                   * CN.ITOBW
L03EDC MOVEQ   #$07,D0                  * CN.ITOBB
L03EDE BTST    D0,$00(A6,A1.L)
       SEQ     $00(A6,A0.L)
       ADDI.B  #$31,$00(A6,A0.L)
       ADDQ.W  #1,A0
       DBF     D0,L03EDE
       ADDQ.W  #1,A1
       RTS

* vector F0
* float to ASCII
L03EF6 MOVEM.L D2-D5,-(A7)   * CN.FTOD
       MOVE.L  A0,-(A7)
       TST.L   $02(A6,A1.L)
       BEQ     L04000
       MOVEQ   #$06,D4
       TST.B   $02(A6,A1.L)
       BGE.S   L03F18
       MOVE.B  #$2D,$00(A6,A0.L)
       ADDQ.W  #1,A0
       JSR     L04A0C(PC)                    * float NEG
L03F18 CMPI.L  #$081B5F60,$00(A6,A1.L)
       BLT.S   L03F2C
       ADDQ.W  #1,D4
       BSR.S   L03F40
       JSR     L0497E(PC)                    * float DIV
       BRA.S   L03F18

L03F2C CMPI.L  #$08184C4C,$00(A6,A1.L)
       BGE.S   L03F6C
       SUBQ.W  #1,D4
       BSR.S   L03F40
       JSR     L048DE(PC)
       BRA.S   L03F2C

L03F40 SUBQ.W  #6,A1
       MOVE.L  #$08045000,$00(A6,A1.L)
       CLR.W   $04(A6,A1.L)
       RTS

L03F50 MOVEQ   #$00,D0
       SWAP    D1
       MOVE.W  D1,D0
       DIVU    #$000A,D0
       SWAP    D0
       MOVE.W  D0,D1
       SWAP    D1
       DIVU    #$000A,D1
       MOVE.W  D1,D0
       SWAP    D1
       EXG     D0,D1
       RTS

L03F6C MOVEQ   #$1F,D0
       SUB.W   $00(A6,A1.L),D0
       MOVE.L  $02(A6,A1.L),D1
       LSR.L   D0,D1
       ADDQ.W  #6,A1
L03F7A ADDQ.L  #5,D1
       BSR.S   L03F50
       ADDQ.W  #1,D4
       CMPI.L  #$00989680,D1
       BGE.S   L03F7A
       ADDQ.W  #8,A0
       MOVEQ   #$06,D2
L03F8C BSR.S   L03F50
       ADDI.B  #$30,D0
       SUBQ.W  #1,A0
       MOVE.B  D0,$00(A6,A0.L)
       DBF     D2,L03F8C
       CMPI.W  #$0005,D4
       BGT.S   L03FAC
       CMPI.W  #$FFFF,D4
       BLT.S   L03FAC
       MOVEQ   #$00,D5
       BRA.S   L03FB0

L03FAC MOVE.L  D4,D5
       MOVEQ   #$00,D4
L03FB0 ADDQ.W  #1,D4
       MOVE.L  A0,D2
       BRA.S   L03FBE

L03FB6 MOVE.B  $00(A6,A0.L),-$01(A6,A0.L)
       ADDQ.W  #1,A0
L03FBE DBF     D4,L03FB6
       MOVE.B  #$2E,-$01(A6,A0.L)
       MOVEA.L D2,A0
       ADDQ.W  #7,A0
L03FCC SUBQ.W  #1,A0
       CMPI.B  #$30,$00(A6,A0.L)
       BEQ.S   L03FCC
       CMPI.B  #$2E,$00(A6,A0.L)
       BEQ.S   L03FE0
       ADDQ.W  #1,A0
L03FE0 TST.W   D5
       BEQ.S   L03FF6
       MOVE.B  #$45,$00(A6,A0.L)
       ADDQ.W  #1,A0
       SUBQ.W  #2,A1
       MOVE.W  D5,$00(A6,A1.L)
       JSR     L03E54(PC)   * CN.ITOD
L03FF6 MOVE.L  A0,D1
       SUB.L   (A7)+,D1
       MOVEM.L (A7)+,D2-D5
       RTS

L04000 MOVE.B  #$30,$00(A6,A0.L)
       ADDQ.W  #1,A0
       ADDQ.W  #6,A1
       BRA.S   L03FF6

L0400C MOVEM.L D0/D5,-(A7)
       CMPI.W  #$000A,D0
       BGE.S   L04034
L04016 SUBQ.W  #1,D5
       BLE.S   L04024
       MOVE.B  #$30,$00(A6,A1.L)
       ADDQ.L  #1,A1
       BRA.S   L04016

L04024 ADDI.W  #$0030,D0
       MOVE.B  D0,$00(A6,A1.L)
       ADDQ.L  #1,A1
       MOVEM.L (A7)+,D0/D5
       RTS

L04034 ANDI.L  #$0000FFFF,D0
       DIVU    #$000A,D0
       SUBQ.W  #1,D5
       BSR.S   L0400C
       SWAP    D0
       BRA.S   L04024

L04046 BSR.S   L0400C
       MOVE.B  #$20,$00(A6,A1.L)
       ADDQ.L  #1,A1
       RTS

L04052 BSR.S   L0400C
       MOVE.B  #$3A,$00(A6,A1.L)
       ADDQ.L  #1,A1
       RTS

* vector CE

L0405E MOVEM.L D1-D5/A2,-(A7)   * CN.DATE
       BSR     L040F6
       SUBA.L  #$16,A1
       MOVE.W  #$0014,$00(A6,A1.L)
       ADDQ.L  #2,A1
       MOVE.W  D2,D0
       MOVEQ   #$04,D5
       BSR.S   L04046
       MULU    #$0003,D4
       MOVEA.L $0002814A,A2  * table of error messages
       MOVE.W  $003A(A2),D0
       LEA     $00(A2,D0.W),A2
       ADDA.W  D4,A2
       BSR.S   L040E8
       MOVE.B  #$20,$00(A6,A1.L)
       ADDQ.L  #1,A1
       MOVEQ   #$02,D5
       MOVE.W  D1,D0
       BSR.S   L04046
       SWAP    D2
       MOVE.W  D2,D0
       BSR.S   L04052
       MOVE.W  D3,D0
       BSR.S   L04052
       SWAP    D3
       MOVE.W  D3,D0
       BSR     L0400C
       SUBA.L  #$00000016,A1
L040B6 MOVEM.L (A7)+,D1-D5/A2
       MOVEQ   #$00,D0
       RTS
       
* vector CE

L040BE MOVEM.L D1-D5/A2,-(A7)   * CN.DAY
       BSR.S   L040F6
       SUBQ.L  #6,A1
       MOVE.W  #$0003,$00(A6,A1.L)
       ADDQ.L  #2,A1
       MULU    #$0003,D0
       MOVEA.L $0002814A,A2
       MOVE.W  $0038(A2),D1
       LEA     $00(A2,D1.W),A2
       ADDA.W  D0,A2
       BSR.S   L040E8
       SUBQ.L  #5,A1
       BRA.S   L040B6

L040E8 MOVEQ   #$02,D0
L040EA MOVE.B  (A2)+,$00(A6,A1.L)
       ADDQ.L  #1,A1
       DBF     D0,L040EA
       RTS

L040F6 MOVE.W  #$003C,D2
       BSR     L0417E
       MOVE.W  D0,D3
       SWAP    D3
       BSR.S   L0417E
       MOVE.W  D0,D3
       DIVU    #$0018,D1
       MOVE.L  D1,D2
       ANDI.L  #$0000FFFF,D1
       MOVE.L  D1,D0
       DIVU    #$0007,D0
       SWAP    D0
       DIVU    #$05B5,D1
       MOVE.W  D1,D2
       ASL.W   #2,D2
       ADDI.W  #$07A9,D2
       CLR.W   D1
       SWAP    D1
       DIVU    #$016D,D1
       MOVEQ   #$00,D4
       CMPI.W  #$0004,D1
       BNE.S   L0413C
       SUBQ.W  #1,D1
       MOVE.W  #$016D,D4
L0413C ADD.W   D1,D2
       SWAP    D1
       ADD.W   D4,D1
       MOVEQ   #$00,D5
       MOVE.W  D2,D4
       ANDI.W  #$0003,D4
       BNE.S   L0414E
       MOVEQ   #$01,D5
L0414E MOVE.W  D5,D4
       ADDI.W  #$003A,D4
       CMP.W   D4,D1
       BLE.S   L0415C
       ADDQ.W  #2,D1
       SUB.W   D5,D1
L0415C MOVE.W  D1,D5
       ADDI.W  #$005C,D5
       MULU    #$0064,D5
       DIVU    #$0BEF,D5
       MOVE.W  D5,D4
       ADDI.W  #$005C,D1
       MULU    #$0BEF,D5
       DIVU    #$0064,D5
       SUB.W   D5,D1
       SUBQ.W  #3,D4
       RTS

L0417E MOVEQ   #$00,D0
       SWAP    D1
       MOVE.W  D1,D0
       DIVU    D2,D0
       SWAP    D0
       MOVE.W  D0,D1
       SWAP    D1
       DIVU    D2,D1
       MOVE.W  D1,D0
       SWAP    D1
       EXG     D0,D1
       RTS

       include flp1_arithm_asm

       include flp1_BASIC1_asm

       include flp1_mdv_routines

       include flp1_net_routines

       include flp1_basic2_asm

       include flp1_basic_commands

       include flp1_basic3_asm

       include flp1_charfount_asm

L0B352 ANDI.W #$0007,D2
       ANDI.W #$003F,D1
       CMPI.B #$36,D1
       BNE.S  L0B368
       BTST   #$01,D2
       BEQ.S  L0B368
       RTS
      
L0B368 movem.l D3/D4/D5/A3,-(A7)
       LEA      L0B458,A3            * keyboard - table
       MOVE.W   $8(A3),D4
       LEA.L    $0(A3,D4.W),A3
       MOVEQ    #$4,D4
L0B37C CMP.B    (A3)+,D1
       BEQ.S    L0B388
       ADDQ.L   #1,A3
       DBF      D4,L0B37C
       BRA.S    L0B392
      
L0B388 MOVE.B   (A3),D1
       OR.B     D2,D1
       JMP      L0B450
      
L0B392 CLR.W    D5
      BCLR     #$0,D2
      BEQ.S    L0B39E
      MOVE.B   #-1,D5
L0B39E LEA      L0B458,A3
      MOVE.W   $0(A3,D2.W),D3
      LEA.L    $0(A3,D3.W),A3
      CLR.L    D3
      MOVE.B   (A3)+,D3
      CMP.B    D3,D1
      BGE.S    L0B3BA
      JMP      L0B446     * !!! PC-RELATIV POSSIBLE !!!
      
L0B3BA CMP.B   (A3)+,D1
       BLE.S    L0B3C4
       JMP      L0B446
L0B3C4 SUBA.W  D3,A3
       MOVE.B  $0(A3,D1.W),D3
       CMPI.B  #-1,D3
       BNE.S   L0B3D8   
       ADD.B    D2,D1
       MOVE.B   D1,$145(A6)
       BRA.S    L0B446
      
L0B3D8 MOVE.B    D3,D1
       MOVE.B     $145(A6),D2
       BEQ.S      L0B414
       CLR.B      $145(A6)
       LEA        L0B458,A3    * !!! PC-RELATIV POSSIBLE !!!
       MOVE.W   $A(A3),D4
       LEA      $0(A3,D4.W),A3
L0B3F2 TST.B   (A3)
       BEQ.S   L0B446
       CMP.B   (A3)+,D2
       BEQ.S   L0B404
       MOVE.B   (A3)+,D4
       ASL.B   #1,D4
       EXT.W   D4
       ADDA.W   D4,A3
       BRA.S   L0B3F2
      
L0B404 MOVE.B   (A3)+,D4
L0B406 BEQ.S   L0B446
      CMP.B   (A3)+,D3
      BEQ.S   L0B412
      ADDQ.L   #1,A3
      SUBQ.B   #1,D4
      BRA.S   L0B406
      
L0B412 MOVE.B   (A3),D1
L0B414 TST.B   $88(A6)    * SV.CAPS
      BEQ.S   L0B43C
      CMPI.B   #$61,D1
      BCS.S   L0B43C
      CMPI.B   #$7A,D1
      BLS.S   L0B438
      CMPI.B   #$80,D1
      BCS.S   L0B43C
      CMPI.B   #$8B,D1
      BHI.S   L0B43C
      BSET   #$5,D1
      BRA.S   L0B43C
      
L0B438 BCLR   #$5,D1
L0B43C TST.B   D5
      BEQ.S   L0B450
      LSL.W   #8,D1
      MOVE.B   D5,D1
      BRA.S   L0B450
      
L0B446 CLR.W    D1
       MOVEM.L (A7)+,D3/D4/D5/A3
       ADDQ.L  #2,(A7)
       RTS
      
L0B450 MOVEM.L   (A7)+,D3/D4/D5/A3
       ADDQ.L     #4,(A7)
oB456 RTS

      include flp1_Keyboard_asm


L0B56C MOVEM.L   D1/D2/D3/A1,-(A7)
       MOVEQ    #$0,D0
       MOVE.L   $146(A6),A1
       MOVE.W   $2(A1),D2
       LEA      $0(A1,D2.W),A1
       TST.B    D1
       BEQ.S    L0B5D6
       MOVE.B   $0(A1,D1.W),D0
       TST.B    D0
       BEQ.S    L0B58E
       MOVE.B   D0,D1
       BRA.S    L0B5D6
L0B58E MOVE.L   D1,D3
       JSR      L0380A
       NOP                * !!! to coform asm !!!
       MOVE.L   D3,D1
       CMPI.W   #$FFF6,D0
       BEQ.S    L0B5DC
       MOVEQ    #$0,D0
       CMPI.W   #$3,D2
       BGE.S    L0B5AA
       MOVEQ    #-1,D0
       BRA.S    L0B5DC
L0B5AA MOVE.L   $146(A6),A1
       MOVE.W   $4(A1),D2
       LEA      $0(A1,D2.W),A1
       MOVE.B   (A1)+,D3
L0B5B8 BEQ.S    L0B5DC
       CMP.B    (A1)+,D1
       BEQ.S    L0B5C4
       ADDQ.L   #3,A1
       SUBQ.B   #1,D3
       BRA.S    L0B5B8
L0B5C4 MOVE.B   (A1)+,D1
       JSR      L03838
       NOP                * !!! to conform asm !!!
       MOVE.B   (A1)+,D1
       JSR      L03838
       NOP                * !!! to conform asm !!!
       MOVE.B   (A1),D1
L0B5D6 JSR      L03838
       NOP                * !!! to conform asm !!!
L0B5DC MOVEM.L (A7)+,D1/D2/D3/A1
       RTS

L0B5E2 MOVEM.L   D0/D1/D2/A1,-(A7)
       MOVE.L   $146(A6),A1
       MOVE.W   $2(A1),D2
       LEA      $0(A1,D2.W),A1
       MOVE.B   $0(A1,D1.W),D0
       TST.B   D0
       BEQ.S   L0B60E
       MOVE.W   D1,D2
L0B5FC MOVE.B   $0(A1,D2.W),D0
       CMP.B   D0,D1
       BEQ.S   L0B60C
       ADDQ.B   #1,D2
       CMP.B   D2,D1
       BNE.S   L0B5FC
       BRA.S   L0B60E
L0B60C MOVE.B   D2,D1
L0B60E MOVEM.L (A7)+,D0/D1/D2/A1
       RTS

       include flp1_tra_tab

       include flp1_sys_mess

        
        ORG $BFE2

L0BFE2 DC.L L0B614
L0BFE6 DC.L L0B71C
L0BFEA DC.L L0B5E2
L0BFEE DC.L L0B56C
L0BFF2 DC.L L0B352

* nr of version

L0BBF6  DC.L $312D3130
L0BBFA  DC.W     $02
        DC.B    'JS'
        DC.W     $00

        END
        
