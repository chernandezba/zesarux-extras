<html><title>Amstrad PCW</title><body bgcolor="#FFFFFF"><h1>Amstrad PCW Hardware Reference</h1>This is an incomplete guide to the hardware of Amstrad's original PCW series - the 8256/8512, 9256/9512, and 10. It does not cover the PCW16.<p>Sources include "All you ever wanted to know..." by CP Software, John Elliott, Jacob Nevins (and his excellent web pages), Cliff Lawson (who kindly OCRed the original Amstrad documentation), Howard Fisher (who lent me a KeyMouse), Paul Hunt, and Kevin Thacker's <a href="http://andercheran.aiind.upv.es/~amstrad"</a>CPC resource</a>, which contains Z80 and FDC info relevant to the PCW. Thanks chaps. Further information is always welcome.<p><i><a href="mailto:richard@systemeD.u-net.com">Richard Fairhurst</a>, 1996-1997</i><h2>Introduction</h2>The PCW's operating system is CP/M, which is comprised of two main parts.<p>The <b>BDOS</b> (Basic Disc Operating System) is the actual OS code itself, written by Digital Research. This should largely remain the same for any machine running CP/M.<p>The <b>BIOS</b> (Basic Input/Output System) provides a set of routines which access the machine's hardware, and was written in the PCW's case by Locomotive/Amstrad. The BIOS routines are called by the BDOS for all screen, disc, and printer operations.<p>Also relevant is the <b>CCP</b> (Command Console Processor), the front-end which accepts commands typed at the A> prompt. The PCW's implementation of CP/M only loads this on system startup, so it must not be overwritten.<p>The <b>TPA</b> (Transient Program Area) is the area of memory, starting at &0100 in a 64k address space, where user programs (.COM files) load and run.<p><h2>I/O ports</h2><h3>External hardware/FDC</h3><table border=0 cellpadding=0><tr><td><code>&00</code></td><td>I   </td><td>FDC status register</td></tr><tr><td><code>&01</code></td><td>I/O </td><td>FDC data register</td></tr><tr><td><code>&88-&8F </code></td><td></td><td>Parallel ports</td></tr><tr><td><code>&9F</code></td><td>I   </td><td>Kempston joystick</td></tr><tr><td><code>&A0</code></td><td>I   </td><td>AMX mouse. Vertical movement: b0-3 4-bit up counter, b4-7 down counter.</td></tr><tr><td><code>&A1</code></td><td>I   </td><td>AMX mouse. Horizontal movement: b0-3 4-bit right counter, b4-7 left counter.</td></tr><tr><td><code>&A2</code></td><td>I   </td><td>AMX mouse. Button states: b2 right, b1 middle, b0 left (0 if pressed, 1 if not).</td></tr><tr><td><code>&A0-&A2</code></td><td></td><td>EMR MIDI interface</td></tr><tr><td><code>&A8-&AF</code></td><td></td><td>Hard drive</td></tr><tr><td><code>&C8-&CF</code></td><td>I/O </td><td>Fax Link interface (<a href=cps8256.html>CPS8256</a>-compatible circuitry).</td></tr><tr><td><code>&D0-&D4</code></td><td></td><td>Kempston mouse (similar to AMX)</td></tr><tr><td><code>&DF</code></td><td>I   </td><td>MasterScan: b0 ink under scan head.</td></tr><tr><td><code>&E0</code></td><td>I   </td><td>Cascade/Spectravideo joystick. b4 right, b3 up, b2 left, b1 fire, b0 down.</td></tr><tr><td><code>&E0-&EF</code></td><td>I/O </td><td><a href=cps8256.html>Serial ports</a> (click for more)</td></tr></table><p><h3>Internal ports</h3><table border=0 cellpadding=0><tr><td><code>&F0</code></td><td>O   </td><td>Select bank for &0000</td></tr><tr><td><code>&F1</code></td><td>O   </td><td>Select bank for &4000</td></tr><tr><td><code>&F2</code></td><td>O   </td><td>Select bank for &8000</td></tr><tr><td><code>&F3</code></td><td>O   </td><td>Select bank for &C000. Usually &87.</td></tr><tr><td valign=top><code>&F4</code></td><td valign=top>O </td><td>b7-b4: when set, force memory reads to access the same bank as writes for &C000, &0000, &8000, and &4000 respectively</td></tr><tr><td valign=top><code>&F4</code></td><td valign=top>I </td><td>As <code>&F8</code>, with the proviso that b3-0 are reset when the port is read. Hence read to re-enable interrupts.</td></tr><tr><td><code>&F5</code></td><td>O   </td><td>Address of roller RAM. b7-5: bank (0-7). b4-1: address / 512.</td></tr><tr><td><code>&F6</code></td><td>O   </td><td>Vertical screen position</td></tr><tr><td><code>&F7</code></td><td>O   </td><td>b7: reverse video. b6: screen enable.</td></tr><tr><td valign=top><code>&F8</code></td><td valign=top>O</td><td>0 end bootstrap, 1 reboot, 2/3/4 connect FDC to NMI/standard interrupts/neither, 5/6 set/clear FDC terminal count, 7/8 screen on/off (for external video), 9/10 disc motor on/off, 11/12 beep on/off</td></tr><tr><td valign=top><code>&F8</code></td><td valign=top>I</td><td>b6: 1 line flyback, read twice in succession indicates frame flyback. b5: FDC interrupt. b4: indicates 32-line screen. b3-0: 300Hz interrupt counter: stays at 1111 until reset by <code>in a,(&F4)</code> (see above).</td></tr><tr><td><code>&FC-&FD </code></td><td>    </td><td>Parallel port (PCW9512)</td></tr><tr><td><code>&FC</code></td><td>I/O </td><td>Matrix printer data</td></tr><tr><td><code>&FD</code></td><td>O</td><td>Matrix printer commands</td></tr><tr><td><code>&FD</code></td><td>I</td><td>Matrix printer status. b7 bailbar (0 out), b2 paper found.</td></tr></table><p>Unlike the CPC, the PCW uses the standard Z80 method of accessing I/O ports. Either the port is stored as a (single-byte) number in C and an instruction like <code>out (c),a</code> used, or the port is passed as part of the instruction <code>out (&port),a</code>.<p><h2>Interrupts/clock speed</h2>Interrupts occur 300 times a second, or 6 times per frame (as on the CPC), at 2 scan lines into frame flyback and every 52 lines thereafter. Frame flyback can be sensed by reading port &F8 twice in succession. Only if b6 is set each time is the PCW in frame flyback.<p>The PCW's clock speed is 3.4MHz, slowed down from a 4MHz CPU. However, access by the video hardware slows down memory accesses to the first 128k (banks 0-7). The BIOS interrupt is also slow, and should be disabled for time-critical operations where operations such as keyboard scanning and disc access are not required.<p><h2>Memory map</h2>The PCW 8256 has 16 banks of 16k each. 512k and expanded machines obviously contain more. The default contents are:<p><table border=0 cellpadding=0><tr><td valign=top>0</td><td><code>&0000-&3FFF</code>: BIOS, extended jumpblock</td></tr><tr><td valign=top>1</td><td><code>&0000-&192F</code>: BIOS<br>			     <code>&1930-&3FFF</code>: screen</td></tr><tr><td valign=top>2</td><td><code>&0000-&332F</code>: screen<br>			     <code>&3600-&37FF</code>: roller RAM<br>		             <code>&3800-&3FFF</code>: character set</td></tr><tr><td valign=top>3</td><td><code>&0000-&3FEF</code>: BIOS, BDOS<br>			     <code>&3FF0-&3FFF</code>: DMA keyboard map</td></tr><tr><td valign=top>4</td><td><code>&0000-&00FF</code>: workspace and BIOS/BDOS jumps<br>			     <code>&0100-&3FFF</code>: TPA</td></tr><tr><td valign=top>5</td><td><code>&0000-&3FFF</code>: TPA</td></tr><tr><td valign=top>6</td><td><code>&0000-&3FFF</code>: TPA</td></tr><tr><td valign=top>7</td><td><code>&0000-&2FFF</code>: common RAM (available for use under all configurations)<br>			     <code>&3000-&3FFF</code>: CP/M workspace</td></tr><tr><td valign=top>8</td><td><code>&0000-&3FFF</code>: CCP, hash tables, data buffers</td></tr><tr><td valign=top>9-16 </td><td><code>&0000-&3FFF</code>: RAM-disc (drive M:)</td></tr></table><p>The roller RAM and screen memory may be stored in any of banks 0-7. Consequently, video circuitry access requirements slow down any code/data access in these banks.<p>Any bank can be mapped into any of the four 16k segments of the Z80's address space using ports &F0-&F3. Under CP/M, the following (named) arrangements are standard:<p><table border=0 cellpadding=0><tr><td></td><td><b>Screen</b></td><td><b>BDOS (0)</b></td><td><b>Extra (n+2)</b></td><td><b>TPA (1)</b></td></tr><tr><td><code>&C000 (&F3) </code></td><td>7 common	 </td><td>7 common       </td><td>7 common      </td><td>7 common </td></tr><tr><td><code>&8000 (&F2) </code></td><td>2 screen	 </td><td>3 BDOS/BIOS    </td><td>3 BDOS/BIOS   </td><td>6 TPA    </td></tr><tr><td><code>&4000 (&F1) </code></td><td>1 screen/BIOS</td><td>1 screen/BIOS  </td><td>8+n CCP or M: </td><td>5 TPA    </td></tr><tr><td><code>&0000 (&F0) </code></td><td>0 BIOS	 </td><td>0 BIOS         </td><td>0 BIOS        </td><td>4 TPA    </td></tr></table><p>Sending the bank number (with b7 set) to one of ports &F0-&F3 selects that bank for reading and writing. Sending the bank number for writing to b0-2 of a port and the bank for reading to b4-b6 (with b7 reset) maps separate banks in for reading and writing: this can only be used for the first 8 banks.<p>As an example of read/write access, to map bank 5 into memory from &4000, you would use <code>ld a,&85: out (&F1),a</code>.<p><h2>Screen memory</h2>The PCW screen on 50Hz (non-US) models is 90x32 characters, or 720x256 pixels. Each pixel line can begin at any address within the first 128k of memory: the address of each line is stored in a 512-byte area of memory known as the roller RAM. By default, the roller RAM is located at &3600 (mapped to &B600) in bank 2, but this may be changed using port &F5. It contains 256 consecutive addresses, stored in the usual Z80 low byte first format: b16-14 control which bank the line is to be found in, b13-3 the address in the bank (in 16-byte units), and b2-0 the offset. Thus a roller RAM address <code>bbbxxxxxxxxxxxyyy</code> indicates bank <code>bbb</code>, address <code>00xxxxxxxxxxx0yyy</code>.<p>Each line is 720, not 90 bytes long. This is because the PCW takes every eighth byte starting at the address pointed to by the roller RAM. In this way, eight screen lines may be interleaved as follows for easy character writing (assuming a consecutive roller RAM arrangement):<p><pre>        (a+0)   (a+8)   (a+16)  ...        (a+1)   (a+9)   (a+17)        (a+2)   (a+10)  (a+18)        (a+3)   (a+11)  (a+19)        (a+4)   (a+12)  (a+20)        (a+5)   (a+13)  (a+21)        (a+6)   (a+14)  (a+22)        (a+7)   (a+15)  (a+23)</pre><p>The vertical position of the screen on the monitor may be altered by incrementing or decrementing port &F6.<p><h2>Keyboard mapping</h2>The PCW's keyboard is directly mapped into the last 16 bytes of bank 3, even when interrupts are disabled. Each key is reflected by one bit in bytes &3FF0-&3FFA.<p><pre>b7:   k2     k1     [+]    .      ,      space  V      X      Z      del<   altb6:   k3     k5     1/2    /      M      N      B      C      lock          k.b5:   k6     k4     shift  ;      K      J      F      D      A             enterb4:   k9     k8     k7     ¤      L      H      G      S      tab           f8b3:   paste  copy   #      P      I      Y      T      W      Q             [-]b2:   f2     cut    return [      O      U      R      E      stop          canb1:   k0     ptr    ]      -      9      7      5      3      2             extrab0:   f4     exit   del>   =      0      8      6      4      1             f6      &3FF0  &3FF1  &3FF2  &3FF3  &3FF4  &3FF5  &3FF6  &3FF7  &3FF8  &3FF9  &3FFA</pre>Bytes &3FFB-&3FFF reflect the keyboard in a different, incomplete way. These bytes are also used by Creative Technology's KeyMouse (in its standard "MicroDesign mode") and the Teqniche 102-key keyboard to provide additional functionality, creating some incompatibilities along the way. Among the more interesting mappings are the following:<p><table border=0 cellpadding=0><tr><td valign=top><code>&3FFB </code></td><td>Standard keyboard &nbsp;<br>KeyMouse</td>    <td>b7-b0 unused (0)<br>b6-b0 horizontal movement counter.</td></tr><tr><td valign=top><code>&3FFC </code></td><td>KeyMouse</td>    <td>b7-b6 high bits of vertical movement counter.</td></tr><tr><td valign=top><code>&3FFD </code></td><td>All<br>Standard keyboard <br>KeyMouse</td>    <td>b7 always set; b6 current state of SHIFT LOCK    <br>b3-b0 cursor keys, b4 matrix key    <br>b3-b0 low bits of vertical movement counter.</td></tr><tr><td><code>&3FFE </code></td><td>KeyMouse</td>    <td>b7 left button, b6 right button.</td></tr></table></body></html>